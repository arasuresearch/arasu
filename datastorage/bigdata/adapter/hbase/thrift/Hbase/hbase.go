// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package Hbase

import (
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf

type Hbase interface {
	// Brings a table on-line (enables it)
	//
	// Parameters:
	//  - TableName: name of the table
	EnableTable(tableName Bytes) (err error)
	// Disables a table (takes it off-line) If it is being served, the master
	// will tell the servers to stop serving it.
	//
	// Parameters:
	//  - TableName: name of the table
	DisableTable(tableName Bytes) (err error)
	// @return true if table is on-line
	//
	// Parameters:
	//  - TableName: name of the table to check
	IsTableEnabled(tableName Bytes) (r bool, err error)
	// Parameters:
	//  - TableNameOrRegionName
	Compact(tableNameOrRegionName Bytes) (err error)
	// Parameters:
	//  - TableNameOrRegionName
	MajorCompact(tableNameOrRegionName Bytes) (err error)
	// List all the userspace tables.
	//
	// @return returns a list of names
	GetTableNames() (r []Text, err error)
	// List all the column families assoicated with a table.
	//
	// @return list of column family descriptors
	//
	// Parameters:
	//  - TableName: table name
	GetColumnDescriptors(tableName Text) (r map[string]*ColumnDescriptor, err error)
	// List the regions associated with a table.
	//
	// @return list of region descriptors
	//
	// Parameters:
	//  - TableName: table name
	GetTableRegions(tableName Text) (r []*TRegionInfo, err error)
	// Create a table with the specified column families.  The name
	// field for each ColumnDescriptor must be set and must end in a
	// colon (:). All other fields are optional and will get default
	// values if not explicitly specified.
	//
	// @throws IllegalArgument if an input parameter is invalid
	//
	// @throws AlreadyExists if the table name already exists
	//
	// Parameters:
	//  - TableName: name of table to create
	//  - ColumnFamilies: list of column family descriptors
	CreateTable(tableName Text, columnFamilies []*ColumnDescriptor) (err error)
	// Deletes a table
	//
	// @throws IOError if table doesn't exist on server or there was some other
	// problem
	//
	// Parameters:
	//  - TableName: name of table to delete
	DeleteTable(tableName Text) (err error)
	// Get a single TCell for the specified table, row, and column at the
	// latest timestamp. Returns an empty list if no such value exists.
	//
	// @return value for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - Attributes: Get attributes
	Get(tableName Text, row Text, column Text, attributes map[string]Text) (r []*TCell, err error)
	// Get the specified number of versions for the specified table,
	// row, and column.
	//
	// @return list of cells for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - NumVersions: number of versions to retrieve
	//  - Attributes: Get attributes
	GetVer(tableName Text, row Text, column Text, numVersions int32, attributes map[string]Text) (r []*TCell, err error)
	// Get the specified number of versions for the specified table,
	// row, and column.  Only versions less than or equal to the specified
	// timestamp will be returned.
	//
	// @return list of cells for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - Timestamp: timestamp
	//  - NumVersions: number of versions to retrieve
	//  - Attributes: Get attributes
	GetVerTs(tableName Text, row Text, column Text, timestamp int64, numVersions int32, attributes map[string]Text) (r []*TCell, err error)
	// Get all the data for the specified table and row at the latest
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Attributes: Get attributes
	GetRow(tableName Text, row Text, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get the specified columns for the specified table and row at the latest
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Columns: List of columns to return, null for all columns
	//  - Attributes: Get attributes
	GetRowWithColumns(tableName Text, row Text, columns []Text, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get all the data for the specified table and row at the specified
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of the table
	//  - Row: row key
	//  - Timestamp: timestamp
	//  - Attributes: Get attributes
	GetRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get the specified columns for the specified table and row at the specified
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Columns: List of columns to return, null for all columns
	//  - Timestamp
	//  - Attributes: Get attributes
	GetRowWithColumnsTs(tableName Text, row Text, columns []Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get all the data for the specified table and rows at the latest
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Rows: row keys
	//  - Attributes: Get attributes
	GetRows(tableName Text, rows []Text, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get the specified columns for the specified table and rows at the latest
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Rows: row keys
	//  - Columns: List of columns to return, null for all columns
	//  - Attributes: Get attributes
	GetRowsWithColumns(tableName Text, rows []Text, columns []Text, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get all the data for the specified table and rows at the specified
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of the table
	//  - Rows: row keys
	//  - Timestamp: timestamp
	//  - Attributes: Get attributes
	GetRowsTs(tableName Text, rows []Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get the specified columns for the specified table and rows at the specified
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Rows: row keys
	//  - Columns: List of columns to return, null for all columns
	//  - Timestamp
	//  - Attributes: Get attributes
	GetRowsWithColumnsTs(tableName Text, rows []Text, columns []Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error)
	// Apply a series of mutations (updates/deletes) to a row in a
	// single transaction.  If an exception is thrown, then the
	// transaction is aborted.  Default current timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Mutations: list of mutation commands
	//  - Attributes: Mutation attributes
	MutateRow(tableName Text, row Text, mutations []*Mutation, attributes map[string]Text) (err error)
	// Apply a series of mutations (updates/deletes) to a row in a
	// single transaction.  If an exception is thrown, then the
	// transaction is aborted.  The specified timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Mutations: list of mutation commands
	//  - Timestamp: timestamp
	//  - Attributes: Mutation attributes
	MutateRowTs(tableName Text, row Text, mutations []*Mutation, timestamp int64, attributes map[string]Text) (err error)
	// Apply a series of batches (each a series of mutations on a single row)
	// in a single transaction.  If an exception is thrown, then the
	// transaction is aborted.  Default current timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - RowBatches: list of row batches
	//  - Attributes: Mutation attributes
	MutateRows(tableName Text, rowBatches []*BatchMutation, attributes map[string]Text) (err error)
	// Apply a series of batches (each a series of mutations on a single row)
	// in a single transaction.  If an exception is thrown, then the
	// transaction is aborted.  The specified timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - RowBatches: list of row batches
	//  - Timestamp: timestamp
	//  - Attributes: Mutation attributes
	MutateRowsTs(tableName Text, rowBatches []*BatchMutation, timestamp int64, attributes map[string]Text) (err error)
	// Atomically increment the column value specified.  Returns the next value post increment.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row to increment
	//  - Column: name of column
	//  - Value: amount to increment by
	AtomicIncrement(tableName Text, row Text, column Text, value int64) (r int64, err error)
	// Delete all cells that match the passed row and column.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: Row to update
	//  - Column: name of column whose value is to be deleted
	//  - Attributes: Delete attributes
	DeleteAll(tableName Text, row Text, column Text, attributes map[string]Text) (err error)
	// Delete all cells that match the passed row and column and whose
	// timestamp is equal-to or older than the passed timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: Row to update
	//  - Column: name of column whose value is to be deleted
	//  - Timestamp: timestamp
	//  - Attributes: Delete attributes
	DeleteAllTs(tableName Text, row Text, column Text, timestamp int64, attributes map[string]Text) (err error)
	// Completely delete the row's cells.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: key of the row to be completely deleted.
	//  - Attributes: Delete attributes
	DeleteAllRow(tableName Text, row Text, attributes map[string]Text) (err error)
	// Increment a cell by the ammount.
	// Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
	// False is the default.  Turn to true if you need the extra performance and can accept some
	// data loss if a thrift server dies with increments still in the queue.
	//
	// Parameters:
	//  - Increment: The single increment to apply
	Increment(increment *TIncrement) (err error)
	// Parameters:
	//  - Increments: The list of increments
	IncrementRows(increments []*TIncrement) (err error)
	// Completely delete the row's cells marked with a timestamp
	// equal-to or older than the passed timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: key of the row to be completely deleted.
	//  - Timestamp: timestamp
	//  - Attributes: Delete attributes
	DeleteAllRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (err error)
	// Get a scanner on the current table, using the Scan instance
	// for the scan parameters.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Scan: Scan instance
	//  - Attributes: Scan attributes
	ScannerOpenWithScan(tableName Text, scan *TScan, attributes map[string]Text) (r ScannerID, err error)
	// Get a scanner on the current table starting at the specified row and
	// ending at the last row in the table.  Return the specified columns.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Attributes: Scan attributes
	ScannerOpen(tableName Text, startRow Text, columns []Text, attributes map[string]Text) (r ScannerID, err error)
	// Get a scanner on the current table starting and stopping at the
	// specified rows.  ending at the last row in the table.  Return the
	// specified columns.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - StopRow: row to stop scanning on. This row is *not* included in the
	// scanner's results
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Attributes: Scan attributes
	ScannerOpenWithStop(tableName Text, startRow Text, stopRow Text, columns []Text, attributes map[string]Text) (r ScannerID, err error)
	// Open a scanner for a given prefix.  That is all rows will have the specified
	// prefix. No other rows will be returned.
	//
	// @return scanner id to use with other scanner calls
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartAndPrefix: the prefix (and thus start row) of the keys you want
	//  - Columns: the columns you want returned
	//  - Attributes: Scan attributes
	ScannerOpenWithPrefix(tableName Text, startAndPrefix Text, columns []Text, attributes map[string]Text) (r ScannerID, err error)
	// Get a scanner on the current table starting at the specified row and
	// ending at the last row in the table.  Return the specified columns.
	// Only values with the specified timestamp are returned.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Timestamp: timestamp
	//  - Attributes: Scan attributes
	ScannerOpenTs(tableName Text, startRow Text, columns []Text, timestamp int64, attributes map[string]Text) (r ScannerID, err error)
	// Get a scanner on the current table starting and stopping at the
	// specified rows.  ending at the last row in the table.  Return the
	// specified columns.  Only values with the specified timestamp are
	// returned.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - StopRow: row to stop scanning on. This row is *not* included in the
	// scanner's results
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Timestamp: timestamp
	//  - Attributes: Scan attributes
	ScannerOpenWithStopTs(tableName Text, startRow Text, stopRow Text, columns []Text, timestamp int64, attributes map[string]Text) (r ScannerID, err error)
	// Returns the scanner's current row value and advances to the next
	// row in the table.  When there are no more rows in the table, or a key
	// greater-than-or-equal-to the scanner's specified stopRow is reached,
	// an empty list is returned.
	//
	// @return a TRowResult containing the current row and a map of the columns to TCells.
	//
	// @throws IllegalArgument if ScannerID is invalid
	//
	// @throws NotFound when the scanner reaches the end
	//
	// Parameters:
	//  - Id: id of a scanner returned by scannerOpen
	ScannerGet(id ScannerID) (r []*TRowResult_, err error)
	// Returns, starting at the scanner's current row value nbRows worth of
	// rows and advances to the next row in the table.  When there are no more
	// rows in the table, or a key greater-than-or-equal-to the scanner's
	// specified stopRow is reached,  an empty list is returned.
	//
	// @return a TRowResult containing the current row and a map of the columns to TCells.
	//
	// @throws IllegalArgument if ScannerID is invalid
	//
	// @throws NotFound when the scanner reaches the end
	//
	// Parameters:
	//  - Id: id of a scanner returned by scannerOpen
	//  - NbRows: number of results to return
	ScannerGetList(id ScannerID, nbRows int32) (r []*TRowResult_, err error)
	// Closes the server-state associated with an open scanner.
	//
	// @throws IllegalArgument if ScannerID is invalid
	//
	// Parameters:
	//  - Id: id of a scanner returned by scannerOpen
	ScannerClose(id ScannerID) (err error)
	// Get the row just before the specified one.
	//
	// @return value for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Family: column name
	GetRowOrBefore(tableName Text, row Text, family Text) (r []*TCell, err error)
	// Get the regininfo for the specified row. It scans
	// the metatable to find region's start and end keys.
	//
	// @return value for specified row/column
	//
	// Parameters:
	//  - Row: row key
	GetRegionInfo(row Text) (r *TRegionInfo, err error)
}

type HbaseClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewHbaseClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *HbaseClient {
	return &HbaseClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewHbaseClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *HbaseClient {
	return &HbaseClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Brings a table on-line (enables it)
//
// Parameters:
//  - TableName: name of the table
func (p *HbaseClient) EnableTable(tableName Bytes) (err error) {
	if err = p.sendEnableTable(tableName); err != nil {
		return
	}
	return p.recvEnableTable()
}

func (p *HbaseClient) sendEnableTable(tableName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("enableTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args5 := NewEnableTableArgs()
	args5.TableName = tableName
	if err = args5.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvEnableTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error7 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error8 error
		error8, err = error7.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error8
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "enableTable failed: out of sequence response")
		return
	}
	result6 := NewEnableTableResult()
	if err = result6.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result6.Io != nil {
		err = result6.Io
		return
	}
	return
}

// Disables a table (takes it off-line) If it is being served, the master
// will tell the servers to stop serving it.
//
// Parameters:
//  - TableName: name of the table
func (p *HbaseClient) DisableTable(tableName Bytes) (err error) {
	if err = p.sendDisableTable(tableName); err != nil {
		return
	}
	return p.recvDisableTable()
}

func (p *HbaseClient) sendDisableTable(tableName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("disableTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args9 := NewDisableTableArgs()
	args9.TableName = tableName
	if err = args9.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvDisableTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error11 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error12 error
		error12, err = error11.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error12
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "disableTable failed: out of sequence response")
		return
	}
	result10 := NewDisableTableResult()
	if err = result10.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result10.Io != nil {
		err = result10.Io
		return
	}
	return
}

// @return true if table is on-line
//
// Parameters:
//  - TableName: name of the table to check
func (p *HbaseClient) IsTableEnabled(tableName Bytes) (r bool, err error) {
	if err = p.sendIsTableEnabled(tableName); err != nil {
		return
	}
	return p.recvIsTableEnabled()
}

func (p *HbaseClient) sendIsTableEnabled(tableName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("isTableEnabled", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args13 := NewIsTableEnabledArgs()
	args13.TableName = tableName
	if err = args13.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvIsTableEnabled() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error15 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error16 error
		error16, err = error15.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error16
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableEnabled failed: out of sequence response")
		return
	}
	result14 := NewIsTableEnabledResult()
	if err = result14.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result14.Io != nil {
		err = result14.Io
		return
	}
	value = result14.Success
	return
}

// Parameters:
//  - TableNameOrRegionName
func (p *HbaseClient) Compact(tableNameOrRegionName Bytes) (err error) {
	if err = p.sendCompact(tableNameOrRegionName); err != nil {
		return
	}
	return p.recvCompact()
}

func (p *HbaseClient) sendCompact(tableNameOrRegionName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("compact", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args17 := NewCompactArgs()
	args17.TableNameOrRegionName = tableNameOrRegionName
	if err = args17.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvCompact() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error19 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error20 error
		error20, err = error19.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error20
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "compact failed: out of sequence response")
		return
	}
	result18 := NewCompactResult()
	if err = result18.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result18.Io != nil {
		err = result18.Io
		return
	}
	return
}

// Parameters:
//  - TableNameOrRegionName
func (p *HbaseClient) MajorCompact(tableNameOrRegionName Bytes) (err error) {
	if err = p.sendMajorCompact(tableNameOrRegionName); err != nil {
		return
	}
	return p.recvMajorCompact()
}

func (p *HbaseClient) sendMajorCompact(tableNameOrRegionName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("majorCompact", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args21 := NewMajorCompactArgs()
	args21.TableNameOrRegionName = tableNameOrRegionName
	if err = args21.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvMajorCompact() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error23 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error24 error
		error24, err = error23.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error24
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "majorCompact failed: out of sequence response")
		return
	}
	result22 := NewMajorCompactResult()
	if err = result22.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result22.Io != nil {
		err = result22.Io
		return
	}
	return
}

// List all the userspace tables.
//
// @return returns a list of names
func (p *HbaseClient) GetTableNames() (r []Text, err error) {
	if err = p.sendGetTableNames(); err != nil {
		return
	}
	return p.recvGetTableNames()
}

func (p *HbaseClient) sendGetTableNames() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableNames", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args25 := NewGetTableNamesArgs()
	if err = args25.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetTableNames() (value []Text, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error27 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error28 error
		error28, err = error27.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error28
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableNames failed: out of sequence response")
		return
	}
	result26 := NewGetTableNamesResult()
	if err = result26.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result26.Io != nil {
		err = result26.Io
		return
	}
	value = result26.Success
	return
}

// List all the column families assoicated with a table.
//
// @return list of column family descriptors
//
// Parameters:
//  - TableName: table name
func (p *HbaseClient) GetColumnDescriptors(tableName Text) (r map[string]*ColumnDescriptor, err error) {
	if err = p.sendGetColumnDescriptors(tableName); err != nil {
		return
	}
	return p.recvGetColumnDescriptors()
}

func (p *HbaseClient) sendGetColumnDescriptors(tableName Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getColumnDescriptors", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args29 := NewGetColumnDescriptorsArgs()
	args29.TableName = tableName
	if err = args29.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetColumnDescriptors() (value map[string]*ColumnDescriptor, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error31 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error32 error
		error32, err = error31.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error32
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getColumnDescriptors failed: out of sequence response")
		return
	}
	result30 := NewGetColumnDescriptorsResult()
	if err = result30.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result30.Io != nil {
		err = result30.Io
		return
	}
	value = result30.Success
	return
}

// List the regions associated with a table.
//
// @return list of region descriptors
//
// Parameters:
//  - TableName: table name
func (p *HbaseClient) GetTableRegions(tableName Text) (r []*TRegionInfo, err error) {
	if err = p.sendGetTableRegions(tableName); err != nil {
		return
	}
	return p.recvGetTableRegions()
}

func (p *HbaseClient) sendGetTableRegions(tableName Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableRegions", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args33 := NewGetTableRegionsArgs()
	args33.TableName = tableName
	if err = args33.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetTableRegions() (value []*TRegionInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error35 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error36 error
		error36, err = error35.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error36
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableRegions failed: out of sequence response")
		return
	}
	result34 := NewGetTableRegionsResult()
	if err = result34.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result34.Io != nil {
		err = result34.Io
		return
	}
	value = result34.Success
	return
}

// Create a table with the specified column families.  The name
// field for each ColumnDescriptor must be set and must end in a
// colon (:). All other fields are optional and will get default
// values if not explicitly specified.
//
// @throws IllegalArgument if an input parameter is invalid
//
// @throws AlreadyExists if the table name already exists
//
// Parameters:
//  - TableName: name of table to create
//  - ColumnFamilies: list of column family descriptors
func (p *HbaseClient) CreateTable(tableName Text, columnFamilies []*ColumnDescriptor) (err error) {
	if err = p.sendCreateTable(tableName, columnFamilies); err != nil {
		return
	}
	return p.recvCreateTable()
}

func (p *HbaseClient) sendCreateTable(tableName Text, columnFamilies []*ColumnDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("createTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args37 := NewCreateTableArgs()
	args37.TableName = tableName
	args37.ColumnFamilies = columnFamilies
	if err = args37.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvCreateTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error39 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error40 error
		error40, err = error39.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error40
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "createTable failed: out of sequence response")
		return
	}
	result38 := NewCreateTableResult()
	if err = result38.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result38.Io != nil {
		err = result38.Io
		return
	} else if result38.Ia != nil {
		err = result38.Ia
		return
	} else if result38.Exist != nil {
		err = result38.Exist
		return
	}
	return
}

// Deletes a table
//
// @throws IOError if table doesn't exist on server or there was some other
// problem
//
// Parameters:
//  - TableName: name of table to delete
func (p *HbaseClient) DeleteTable(tableName Text) (err error) {
	if err = p.sendDeleteTable(tableName); err != nil {
		return
	}
	return p.recvDeleteTable()
}

func (p *HbaseClient) sendDeleteTable(tableName Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args41 := NewDeleteTableArgs()
	args41.TableName = tableName
	if err = args41.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvDeleteTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		error44, err = error43.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error44
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteTable failed: out of sequence response")
		return
	}
	result42 := NewDeleteTableResult()
	if err = result42.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result42.Io != nil {
		err = result42.Io
		return
	}
	return
}

// Get a single TCell for the specified table, row, and column at the
// latest timestamp. Returns an empty list if no such value exists.
//
// @return value for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - Attributes: Get attributes
func (p *HbaseClient) Get(tableName Text, row Text, column Text, attributes map[string]Text) (r []*TCell, err error) {
	if err = p.sendGet(tableName, row, column, attributes); err != nil {
		return
	}
	return p.recvGet()
}

func (p *HbaseClient) sendGet(tableName Text, row Text, column Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args45 := NewGetArgs()
	args45.TableName = tableName
	args45.Row = row
	args45.Column = column
	args45.Attributes = attributes
	if err = args45.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGet() (value []*TCell, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		error48, err = error47.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error48
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	result46 := NewGetResult()
	if err = result46.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result46.Io != nil {
		err = result46.Io
		return
	}
	value = result46.Success
	return
}

// Get the specified number of versions for the specified table,
// row, and column.
//
// @return list of cells for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - NumVersions: number of versions to retrieve
//  - Attributes: Get attributes
func (p *HbaseClient) GetVer(tableName Text, row Text, column Text, numVersions int32, attributes map[string]Text) (r []*TCell, err error) {
	if err = p.sendGetVer(tableName, row, column, numVersions, attributes); err != nil {
		return
	}
	return p.recvGetVer()
}

func (p *HbaseClient) sendGetVer(tableName Text, row Text, column Text, numVersions int32, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getVer", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args49 := NewGetVerArgs()
	args49.TableName = tableName
	args49.Row = row
	args49.Column = column
	args49.NumVersions = numVersions
	args49.Attributes = attributes
	if err = args49.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetVer() (value []*TCell, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error51 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error52 error
		error52, err = error51.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error52
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getVer failed: out of sequence response")
		return
	}
	result50 := NewGetVerResult()
	if err = result50.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result50.Io != nil {
		err = result50.Io
		return
	}
	value = result50.Success
	return
}

// Get the specified number of versions for the specified table,
// row, and column.  Only versions less than or equal to the specified
// timestamp will be returned.
//
// @return list of cells for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - Timestamp: timestamp
//  - NumVersions: number of versions to retrieve
//  - Attributes: Get attributes
func (p *HbaseClient) GetVerTs(tableName Text, row Text, column Text, timestamp int64, numVersions int32, attributes map[string]Text) (r []*TCell, err error) {
	if err = p.sendGetVerTs(tableName, row, column, timestamp, numVersions, attributes); err != nil {
		return
	}
	return p.recvGetVerTs()
}

func (p *HbaseClient) sendGetVerTs(tableName Text, row Text, column Text, timestamp int64, numVersions int32, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getVerTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args53 := NewGetVerTsArgs()
	args53.TableName = tableName
	args53.Row = row
	args53.Column = column
	args53.Timestamp = timestamp
	args53.NumVersions = numVersions
	args53.Attributes = attributes
	if err = args53.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetVerTs() (value []*TCell, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		error56, err = error55.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error56
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getVerTs failed: out of sequence response")
		return
	}
	result54 := NewGetVerTsResult()
	if err = result54.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result54.Io != nil {
		err = result54.Io
		return
	}
	value = result54.Success
	return
}

// Get all the data for the specified table and row at the latest
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Attributes: Get attributes
func (p *HbaseClient) GetRow(tableName Text, row Text, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRow(tableName, row, attributes); err != nil {
		return
	}
	return p.recvGetRow()
}

func (p *HbaseClient) sendGetRow(tableName Text, row Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRow", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args57 := NewGetRowArgs()
	args57.TableName = tableName
	args57.Row = row
	args57.Attributes = attributes
	if err = args57.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRow() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		error60, err = error59.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error60
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRow failed: out of sequence response")
		return
	}
	result58 := NewGetRowResult()
	if err = result58.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result58.Io != nil {
		err = result58.Io
		return
	}
	value = result58.Success
	return
}

// Get the specified columns for the specified table and row at the latest
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Columns: List of columns to return, null for all columns
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowWithColumns(tableName Text, row Text, columns []Text, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowWithColumns(tableName, row, columns, attributes); err != nil {
		return
	}
	return p.recvGetRowWithColumns()
}

func (p *HbaseClient) sendGetRowWithColumns(tableName Text, row Text, columns []Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowWithColumns", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args61 := NewGetRowWithColumnsArgs()
	args61.TableName = tableName
	args61.Row = row
	args61.Columns = columns
	args61.Attributes = attributes
	if err = args61.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRowWithColumns() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		error64, err = error63.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error64
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowWithColumns failed: out of sequence response")
		return
	}
	result62 := NewGetRowWithColumnsResult()
	if err = result62.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result62.Io != nil {
		err = result62.Io
		return
	}
	value = result62.Success
	return
}

// Get all the data for the specified table and row at the specified
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of the table
//  - Row: row key
//  - Timestamp: timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowTs(tableName, row, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowTs()
}

func (p *HbaseClient) sendGetRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args65 := NewGetRowTsArgs()
	args65.TableName = tableName
	args65.Row = row
	args65.Timestamp = timestamp
	args65.Attributes = attributes
	if err = args65.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRowTs() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error67 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error68 error
		error68, err = error67.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error68
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowTs failed: out of sequence response")
		return
	}
	result66 := NewGetRowTsResult()
	if err = result66.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result66.Io != nil {
		err = result66.Io
		return
	}
	value = result66.Success
	return
}

// Get the specified columns for the specified table and row at the specified
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Columns: List of columns to return, null for all columns
//  - Timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowWithColumnsTs(tableName Text, row Text, columns []Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowWithColumnsTs(tableName, row, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowWithColumnsTs()
}

func (p *HbaseClient) sendGetRowWithColumnsTs(tableName Text, row Text, columns []Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args69 := NewGetRowWithColumnsTsArgs()
	args69.TableName = tableName
	args69.Row = row
	args69.Columns = columns
	args69.Timestamp = timestamp
	args69.Attributes = attributes
	if err = args69.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRowWithColumnsTs() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error71 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error72 error
		error72, err = error71.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error72
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowWithColumnsTs failed: out of sequence response")
		return
	}
	result70 := NewGetRowWithColumnsTsResult()
	if err = result70.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result70.Io != nil {
		err = result70.Io
		return
	}
	value = result70.Success
	return
}

// Get all the data for the specified table and rows at the latest
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Rows: row keys
//  - Attributes: Get attributes
func (p *HbaseClient) GetRows(tableName Text, rows []Text, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRows(tableName, rows, attributes); err != nil {
		return
	}
	return p.recvGetRows()
}

func (p *HbaseClient) sendGetRows(tableName Text, rows []Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRows", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args73 := NewGetRowsArgs()
	args73.TableName = tableName
	args73.Rows = rows
	args73.Attributes = attributes
	if err = args73.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRows() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error75 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error76 error
		error76, err = error75.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error76
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRows failed: out of sequence response")
		return
	}
	result74 := NewGetRowsResult()
	if err = result74.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result74.Io != nil {
		err = result74.Io
		return
	}
	value = result74.Success
	return
}

// Get the specified columns for the specified table and rows at the latest
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Rows: row keys
//  - Columns: List of columns to return, null for all columns
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowsWithColumns(tableName Text, rows []Text, columns []Text, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowsWithColumns(tableName, rows, columns, attributes); err != nil {
		return
	}
	return p.recvGetRowsWithColumns()
}

func (p *HbaseClient) sendGetRowsWithColumns(tableName Text, rows []Text, columns []Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowsWithColumns", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args77 := NewGetRowsWithColumnsArgs()
	args77.TableName = tableName
	args77.Rows = rows
	args77.Columns = columns
	args77.Attributes = attributes
	if err = args77.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRowsWithColumns() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error79 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error80 error
		error80, err = error79.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error80
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowsWithColumns failed: out of sequence response")
		return
	}
	result78 := NewGetRowsWithColumnsResult()
	if err = result78.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result78.Io != nil {
		err = result78.Io
		return
	}
	value = result78.Success
	return
}

// Get all the data for the specified table and rows at the specified
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of the table
//  - Rows: row keys
//  - Timestamp: timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowsTs(tableName Text, rows []Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowsTs(tableName, rows, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowsTs()
}

func (p *HbaseClient) sendGetRowsTs(tableName Text, rows []Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowsTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args81 := NewGetRowsTsArgs()
	args81.TableName = tableName
	args81.Rows = rows
	args81.Timestamp = timestamp
	args81.Attributes = attributes
	if err = args81.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRowsTs() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error83 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error84 error
		error84, err = error83.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error84
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowsTs failed: out of sequence response")
		return
	}
	result82 := NewGetRowsTsResult()
	if err = result82.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result82.Io != nil {
		err = result82.Io
		return
	}
	value = result82.Success
	return
}

// Get the specified columns for the specified table and rows at the specified
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Rows: row keys
//  - Columns: List of columns to return, null for all columns
//  - Timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowsWithColumnsTs(tableName Text, rows []Text, columns []Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowsWithColumnsTs(tableName, rows, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowsWithColumnsTs()
}

func (p *HbaseClient) sendGetRowsWithColumnsTs(tableName Text, rows []Text, columns []Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args85 := NewGetRowsWithColumnsTsArgs()
	args85.TableName = tableName
	args85.Rows = rows
	args85.Columns = columns
	args85.Timestamp = timestamp
	args85.Attributes = attributes
	if err = args85.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRowsWithColumnsTs() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error87 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error88 error
		error88, err = error87.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error88
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowsWithColumnsTs failed: out of sequence response")
		return
	}
	result86 := NewGetRowsWithColumnsTsResult()
	if err = result86.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result86.Io != nil {
		err = result86.Io
		return
	}
	value = result86.Success
	return
}

// Apply a series of mutations (updates/deletes) to a row in a
// single transaction.  If an exception is thrown, then the
// transaction is aborted.  Default current timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Mutations: list of mutation commands
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRow(tableName Text, row Text, mutations []*Mutation, attributes map[string]Text) (err error) {
	if err = p.sendMutateRow(tableName, row, mutations, attributes); err != nil {
		return
	}
	return p.recvMutateRow()
}

func (p *HbaseClient) sendMutateRow(tableName Text, row Text, mutations []*Mutation, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRow", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args89 := NewMutateRowArgs()
	args89.TableName = tableName
	args89.Row = row
	args89.Mutations = mutations
	args89.Attributes = attributes
	if err = args89.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvMutateRow() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error91 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error92 error
		error92, err = error91.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error92
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRow failed: out of sequence response")
		return
	}
	result90 := NewMutateRowResult()
	if err = result90.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result90.Io != nil {
		err = result90.Io
		return
	} else if result90.Ia != nil {
		err = result90.Ia
		return
	}
	return
}

// Apply a series of mutations (updates/deletes) to a row in a
// single transaction.  If an exception is thrown, then the
// transaction is aborted.  The specified timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Mutations: list of mutation commands
//  - Timestamp: timestamp
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRowTs(tableName Text, row Text, mutations []*Mutation, timestamp int64, attributes map[string]Text) (err error) {
	if err = p.sendMutateRowTs(tableName, row, mutations, timestamp, attributes); err != nil {
		return
	}
	return p.recvMutateRowTs()
}

func (p *HbaseClient) sendMutateRowTs(tableName Text, row Text, mutations []*Mutation, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRowTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args93 := NewMutateRowTsArgs()
	args93.TableName = tableName
	args93.Row = row
	args93.Mutations = mutations
	args93.Timestamp = timestamp
	args93.Attributes = attributes
	if err = args93.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvMutateRowTs() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error95 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error96 error
		error96, err = error95.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error96
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRowTs failed: out of sequence response")
		return
	}
	result94 := NewMutateRowTsResult()
	if err = result94.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result94.Io != nil {
		err = result94.Io
		return
	} else if result94.Ia != nil {
		err = result94.Ia
		return
	}
	return
}

// Apply a series of batches (each a series of mutations on a single row)
// in a single transaction.  If an exception is thrown, then the
// transaction is aborted.  Default current timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - RowBatches: list of row batches
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRows(tableName Text, rowBatches []*BatchMutation, attributes map[string]Text) (err error) {
	if err = p.sendMutateRows(tableName, rowBatches, attributes); err != nil {
		return
	}
	return p.recvMutateRows()
}

func (p *HbaseClient) sendMutateRows(tableName Text, rowBatches []*BatchMutation, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRows", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args97 := NewMutateRowsArgs()
	args97.TableName = tableName
	args97.RowBatches = rowBatches
	args97.Attributes = attributes
	if err = args97.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvMutateRows() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error99 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error100 error
		error100, err = error99.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error100
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRows failed: out of sequence response")
		return
	}
	result98 := NewMutateRowsResult()
	if err = result98.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result98.Io != nil {
		err = result98.Io
		return
	} else if result98.Ia != nil {
		err = result98.Ia
		return
	}
	return
}

// Apply a series of batches (each a series of mutations on a single row)
// in a single transaction.  If an exception is thrown, then the
// transaction is aborted.  The specified timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - RowBatches: list of row batches
//  - Timestamp: timestamp
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRowsTs(tableName Text, rowBatches []*BatchMutation, timestamp int64, attributes map[string]Text) (err error) {
	if err = p.sendMutateRowsTs(tableName, rowBatches, timestamp, attributes); err != nil {
		return
	}
	return p.recvMutateRowsTs()
}

func (p *HbaseClient) sendMutateRowsTs(tableName Text, rowBatches []*BatchMutation, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRowsTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args101 := NewMutateRowsTsArgs()
	args101.TableName = tableName
	args101.RowBatches = rowBatches
	args101.Timestamp = timestamp
	args101.Attributes = attributes
	if err = args101.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvMutateRowsTs() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error103 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error104 error
		error104, err = error103.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error104
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRowsTs failed: out of sequence response")
		return
	}
	result102 := NewMutateRowsTsResult()
	if err = result102.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result102.Io != nil {
		err = result102.Io
		return
	} else if result102.Ia != nil {
		err = result102.Ia
		return
	}
	return
}

// Atomically increment the column value specified.  Returns the next value post increment.
//
// Parameters:
//  - TableName: name of table
//  - Row: row to increment
//  - Column: name of column
//  - Value: amount to increment by
func (p *HbaseClient) AtomicIncrement(tableName Text, row Text, column Text, value int64) (r int64, err error) {
	if err = p.sendAtomicIncrement(tableName, row, column, value); err != nil {
		return
	}
	return p.recvAtomicIncrement()
}

func (p *HbaseClient) sendAtomicIncrement(tableName Text, row Text, column Text, value int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("atomicIncrement", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args105 := NewAtomicIncrementArgs()
	args105.TableName = tableName
	args105.Row = row
	args105.Column = column
	args105.Value = value
	if err = args105.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvAtomicIncrement() (value int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error107 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error108 error
		error108, err = error107.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error108
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "atomicIncrement failed: out of sequence response")
		return
	}
	result106 := NewAtomicIncrementResult()
	if err = result106.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result106.Io != nil {
		err = result106.Io
		return
	} else if result106.Ia != nil {
		err = result106.Ia
		return
	}
	value = result106.Success
	return
}

// Delete all cells that match the passed row and column.
//
// Parameters:
//  - TableName: name of table
//  - Row: Row to update
//  - Column: name of column whose value is to be deleted
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAll(tableName Text, row Text, column Text, attributes map[string]Text) (err error) {
	if err = p.sendDeleteAll(tableName, row, column, attributes); err != nil {
		return
	}
	return p.recvDeleteAll()
}

func (p *HbaseClient) sendDeleteAll(tableName Text, row Text, column Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteAll", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args109 := NewDeleteAllArgs()
	args109.TableName = tableName
	args109.Row = row
	args109.Column = column
	args109.Attributes = attributes
	if err = args109.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvDeleteAll() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error111 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error112 error
		error112, err = error111.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error112
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteAll failed: out of sequence response")
		return
	}
	result110 := NewDeleteAllResult()
	if err = result110.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result110.Io != nil {
		err = result110.Io
		return
	}
	return
}

// Delete all cells that match the passed row and column and whose
// timestamp is equal-to or older than the passed timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: Row to update
//  - Column: name of column whose value is to be deleted
//  - Timestamp: timestamp
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAllTs(tableName Text, row Text, column Text, timestamp int64, attributes map[string]Text) (err error) {
	if err = p.sendDeleteAllTs(tableName, row, column, timestamp, attributes); err != nil {
		return
	}
	return p.recvDeleteAllTs()
}

func (p *HbaseClient) sendDeleteAllTs(tableName Text, row Text, column Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteAllTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args113 := NewDeleteAllTsArgs()
	args113.TableName = tableName
	args113.Row = row
	args113.Column = column
	args113.Timestamp = timestamp
	args113.Attributes = attributes
	if err = args113.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvDeleteAllTs() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error115 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error116 error
		error116, err = error115.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error116
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteAllTs failed: out of sequence response")
		return
	}
	result114 := NewDeleteAllTsResult()
	if err = result114.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result114.Io != nil {
		err = result114.Io
		return
	}
	return
}

// Completely delete the row's cells.
//
// Parameters:
//  - TableName: name of table
//  - Row: key of the row to be completely deleted.
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAllRow(tableName Text, row Text, attributes map[string]Text) (err error) {
	if err = p.sendDeleteAllRow(tableName, row, attributes); err != nil {
		return
	}
	return p.recvDeleteAllRow()
}

func (p *HbaseClient) sendDeleteAllRow(tableName Text, row Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteAllRow", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args117 := NewDeleteAllRowArgs()
	args117.TableName = tableName
	args117.Row = row
	args117.Attributes = attributes
	if err = args117.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvDeleteAllRow() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error119 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error120 error
		error120, err = error119.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error120
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteAllRow failed: out of sequence response")
		return
	}
	result118 := NewDeleteAllRowResult()
	if err = result118.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result118.Io != nil {
		err = result118.Io
		return
	}
	return
}

// Increment a cell by the ammount.
// Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
// False is the default.  Turn to true if you need the extra performance and can accept some
// data loss if a thrift server dies with increments still in the queue.
//
// Parameters:
//  - Increment: The single increment to apply
func (p *HbaseClient) Increment(increment *TIncrement) (err error) {
	if err = p.sendIncrement(increment); err != nil {
		return
	}
	return p.recvIncrement()
}

func (p *HbaseClient) sendIncrement(increment *TIncrement) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("increment", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args121 := NewIncrementArgs()
	args121.Increment = increment
	if err = args121.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvIncrement() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error123 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error124 error
		error124, err = error123.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error124
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "increment failed: out of sequence response")
		return
	}
	result122 := NewIncrementResult()
	if err = result122.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result122.Io != nil {
		err = result122.Io
		return
	}
	return
}

// Parameters:
//  - Increments: The list of increments
func (p *HbaseClient) IncrementRows(increments []*TIncrement) (err error) {
	if err = p.sendIncrementRows(increments); err != nil {
		return
	}
	return p.recvIncrementRows()
}

func (p *HbaseClient) sendIncrementRows(increments []*TIncrement) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("incrementRows", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args125 := NewIncrementRowsArgs()
	args125.Increments = increments
	if err = args125.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvIncrementRows() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error127 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error128 error
		error128, err = error127.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error128
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "incrementRows failed: out of sequence response")
		return
	}
	result126 := NewIncrementRowsResult()
	if err = result126.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result126.Io != nil {
		err = result126.Io
		return
	}
	return
}

// Completely delete the row's cells marked with a timestamp
// equal-to or older than the passed timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: key of the row to be completely deleted.
//  - Timestamp: timestamp
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAllRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (err error) {
	if err = p.sendDeleteAllRowTs(tableName, row, timestamp, attributes); err != nil {
		return
	}
	return p.recvDeleteAllRowTs()
}

func (p *HbaseClient) sendDeleteAllRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteAllRowTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args129 := NewDeleteAllRowTsArgs()
	args129.TableName = tableName
	args129.Row = row
	args129.Timestamp = timestamp
	args129.Attributes = attributes
	if err = args129.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvDeleteAllRowTs() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error131 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error132 error
		error132, err = error131.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error132
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteAllRowTs failed: out of sequence response")
		return
	}
	result130 := NewDeleteAllRowTsResult()
	if err = result130.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result130.Io != nil {
		err = result130.Io
		return
	}
	return
}

// Get a scanner on the current table, using the Scan instance
// for the scan parameters.
//
// Parameters:
//  - TableName: name of table
//  - Scan: Scan instance
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithScan(tableName Text, scan *TScan, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenWithScan(tableName, scan, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithScan()
}

func (p *HbaseClient) sendScannerOpenWithScan(tableName Text, scan *TScan, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenWithScan", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args133 := NewScannerOpenWithScanArgs()
	args133.TableName = tableName
	args133.Scan = scan
	args133.Attributes = attributes
	if err = args133.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvScannerOpenWithScan() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error135 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error136 error
		error136, err = error135.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error136
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenWithScan failed: out of sequence response")
		return
	}
	result134 := NewScannerOpenWithScanResult()
	if err = result134.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result134.Io != nil {
		err = result134.Io
		return
	}
	value = result134.Success
	return
}

// Get a scanner on the current table starting at the specified row and
// ending at the last row in the table.  Return the specified columns.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpen(tableName Text, startRow Text, columns []Text, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpen(tableName, startRow, columns, attributes); err != nil {
		return
	}
	return p.recvScannerOpen()
}

func (p *HbaseClient) sendScannerOpen(tableName Text, startRow Text, columns []Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpen", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args137 := NewScannerOpenArgs()
	args137.TableName = tableName
	args137.StartRow = startRow
	args137.Columns = columns
	args137.Attributes = attributes
	if err = args137.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvScannerOpen() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error139 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error140 error
		error140, err = error139.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error140
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpen failed: out of sequence response")
		return
	}
	result138 := NewScannerOpenResult()
	if err = result138.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result138.Io != nil {
		err = result138.Io
		return
	}
	value = result138.Success
	return
}

// Get a scanner on the current table starting and stopping at the
// specified rows.  ending at the last row in the table.  Return the
// specified columns.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - StopRow: row to stop scanning on. This row is *not* included in the
// scanner's results
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithStop(tableName Text, startRow Text, stopRow Text, columns []Text, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenWithStop(tableName, startRow, stopRow, columns, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithStop()
}

func (p *HbaseClient) sendScannerOpenWithStop(tableName Text, startRow Text, stopRow Text, columns []Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenWithStop", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args141 := NewScannerOpenWithStopArgs()
	args141.TableName = tableName
	args141.StartRow = startRow
	args141.StopRow = stopRow
	args141.Columns = columns
	args141.Attributes = attributes
	if err = args141.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvScannerOpenWithStop() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error143 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error144 error
		error144, err = error143.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error144
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenWithStop failed: out of sequence response")
		return
	}
	result142 := NewScannerOpenWithStopResult()
	if err = result142.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result142.Io != nil {
		err = result142.Io
		return
	}
	value = result142.Success
	return
}

// Open a scanner for a given prefix.  That is all rows will have the specified
// prefix. No other rows will be returned.
//
// @return scanner id to use with other scanner calls
//
// Parameters:
//  - TableName: name of table
//  - StartAndPrefix: the prefix (and thus start row) of the keys you want
//  - Columns: the columns you want returned
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithPrefix(tableName Text, startAndPrefix Text, columns []Text, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithPrefix()
}

func (p *HbaseClient) sendScannerOpenWithPrefix(tableName Text, startAndPrefix Text, columns []Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args145 := NewScannerOpenWithPrefixArgs()
	args145.TableName = tableName
	args145.StartAndPrefix = startAndPrefix
	args145.Columns = columns
	args145.Attributes = attributes
	if err = args145.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvScannerOpenWithPrefix() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error147 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error148 error
		error148, err = error147.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error148
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenWithPrefix failed: out of sequence response")
		return
	}
	result146 := NewScannerOpenWithPrefixResult()
	if err = result146.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result146.Io != nil {
		err = result146.Io
		return
	}
	value = result146.Success
	return
}

// Get a scanner on the current table starting at the specified row and
// ending at the last row in the table.  Return the specified columns.
// Only values with the specified timestamp are returned.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Timestamp: timestamp
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenTs(tableName Text, startRow Text, columns []Text, timestamp int64, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenTs(tableName, startRow, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvScannerOpenTs()
}

func (p *HbaseClient) sendScannerOpenTs(tableName Text, startRow Text, columns []Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args149 := NewScannerOpenTsArgs()
	args149.TableName = tableName
	args149.StartRow = startRow
	args149.Columns = columns
	args149.Timestamp = timestamp
	args149.Attributes = attributes
	if err = args149.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvScannerOpenTs() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error151 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error152 error
		error152, err = error151.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error152
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenTs failed: out of sequence response")
		return
	}
	result150 := NewScannerOpenTsResult()
	if err = result150.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result150.Io != nil {
		err = result150.Io
		return
	}
	value = result150.Success
	return
}

// Get a scanner on the current table starting and stopping at the
// specified rows.  ending at the last row in the table.  Return the
// specified columns.  Only values with the specified timestamp are
// returned.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - StopRow: row to stop scanning on. This row is *not* included in the
// scanner's results
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Timestamp: timestamp
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithStopTs(tableName Text, startRow Text, stopRow Text, columns []Text, timestamp int64, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithStopTs()
}

func (p *HbaseClient) sendScannerOpenWithStopTs(tableName Text, startRow Text, stopRow Text, columns []Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args153 := NewScannerOpenWithStopTsArgs()
	args153.TableName = tableName
	args153.StartRow = startRow
	args153.StopRow = stopRow
	args153.Columns = columns
	args153.Timestamp = timestamp
	args153.Attributes = attributes
	if err = args153.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvScannerOpenWithStopTs() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error155 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error156 error
		error156, err = error155.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error156
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenWithStopTs failed: out of sequence response")
		return
	}
	result154 := NewScannerOpenWithStopTsResult()
	if err = result154.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result154.Io != nil {
		err = result154.Io
		return
	}
	value = result154.Success
	return
}

// Returns the scanner's current row value and advances to the next
// row in the table.  When there are no more rows in the table, or a key
// greater-than-or-equal-to the scanner's specified stopRow is reached,
// an empty list is returned.
//
// @return a TRowResult containing the current row and a map of the columns to TCells.
//
// @throws IllegalArgument if ScannerID is invalid
//
// @throws NotFound when the scanner reaches the end
//
// Parameters:
//  - Id: id of a scanner returned by scannerOpen
func (p *HbaseClient) ScannerGet(id ScannerID) (r []*TRowResult_, err error) {
	if err = p.sendScannerGet(id); err != nil {
		return
	}
	return p.recvScannerGet()
}

func (p *HbaseClient) sendScannerGet(id ScannerID) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerGet", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args157 := NewScannerGetArgs()
	args157.Id = id
	if err = args157.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvScannerGet() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error159 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error160 error
		error160, err = error159.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error160
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerGet failed: out of sequence response")
		return
	}
	result158 := NewScannerGetResult()
	if err = result158.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result158.Io != nil {
		err = result158.Io
		return
	} else if result158.Ia != nil {
		err = result158.Ia
		return
	}
	value = result158.Success
	return
}

// Returns, starting at the scanner's current row value nbRows worth of
// rows and advances to the next row in the table.  When there are no more
// rows in the table, or a key greater-than-or-equal-to the scanner's
// specified stopRow is reached,  an empty list is returned.
//
// @return a TRowResult containing the current row and a map of the columns to TCells.
//
// @throws IllegalArgument if ScannerID is invalid
//
// @throws NotFound when the scanner reaches the end
//
// Parameters:
//  - Id: id of a scanner returned by scannerOpen
//  - NbRows: number of results to return
func (p *HbaseClient) ScannerGetList(id ScannerID, nbRows int32) (r []*TRowResult_, err error) {
	if err = p.sendScannerGetList(id, nbRows); err != nil {
		return
	}
	return p.recvScannerGetList()
}

func (p *HbaseClient) sendScannerGetList(id ScannerID, nbRows int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerGetList", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args161 := NewScannerGetListArgs()
	args161.Id = id
	args161.NbRows = nbRows
	if err = args161.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvScannerGetList() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error163 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error164 error
		error164, err = error163.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error164
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerGetList failed: out of sequence response")
		return
	}
	result162 := NewScannerGetListResult()
	if err = result162.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result162.Io != nil {
		err = result162.Io
		return
	} else if result162.Ia != nil {
		err = result162.Ia
		return
	}
	value = result162.Success
	return
}

// Closes the server-state associated with an open scanner.
//
// @throws IllegalArgument if ScannerID is invalid
//
// Parameters:
//  - Id: id of a scanner returned by scannerOpen
func (p *HbaseClient) ScannerClose(id ScannerID) (err error) {
	if err = p.sendScannerClose(id); err != nil {
		return
	}
	return p.recvScannerClose()
}

func (p *HbaseClient) sendScannerClose(id ScannerID) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerClose", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args165 := NewScannerCloseArgs()
	args165.Id = id
	if err = args165.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvScannerClose() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error167 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error168 error
		error168, err = error167.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error168
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerClose failed: out of sequence response")
		return
	}
	result166 := NewScannerCloseResult()
	if err = result166.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result166.Io != nil {
		err = result166.Io
		return
	} else if result166.Ia != nil {
		err = result166.Ia
		return
	}
	return
}

// Get the row just before the specified one.
//
// @return value for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Family: column name
func (p *HbaseClient) GetRowOrBefore(tableName Text, row Text, family Text) (r []*TCell, err error) {
	if err = p.sendGetRowOrBefore(tableName, row, family); err != nil {
		return
	}
	return p.recvGetRowOrBefore()
}

func (p *HbaseClient) sendGetRowOrBefore(tableName Text, row Text, family Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowOrBefore", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args169 := NewGetRowOrBeforeArgs()
	args169.TableName = tableName
	args169.Row = row
	args169.Family = family
	if err = args169.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRowOrBefore() (value []*TCell, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error171 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error172 error
		error172, err = error171.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error172
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowOrBefore failed: out of sequence response")
		return
	}
	result170 := NewGetRowOrBeforeResult()
	if err = result170.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result170.Io != nil {
		err = result170.Io
		return
	}
	value = result170.Success
	return
}

// Get the regininfo for the specified row. It scans
// the metatable to find region's start and end keys.
//
// @return value for specified row/column
//
// Parameters:
//  - Row: row key
func (p *HbaseClient) GetRegionInfo(row Text) (r *TRegionInfo, err error) {
	if err = p.sendGetRegionInfo(row); err != nil {
		return
	}
	return p.recvGetRegionInfo()
}

func (p *HbaseClient) sendGetRegionInfo(row Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRegionInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args173 := NewGetRegionInfoArgs()
	args173.Row = row
	if err = args173.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *HbaseClient) recvGetRegionInfo() (value *TRegionInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error175 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error176 error
		error176, err = error175.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error176
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRegionInfo failed: out of sequence response")
		return
	}
	result174 := NewGetRegionInfoResult()
	if err = result174.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result174.Io != nil {
		err = result174.Io
		return
	}
	value = result174.Success
	return
}

type HbaseProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Hbase
}

func (p *HbaseProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *HbaseProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *HbaseProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewHbaseProcessor(handler Hbase) *HbaseProcessor {

	self177 := &HbaseProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self177.processorMap["enableTable"] = &hbaseProcessorEnableTable{handler: handler}
	self177.processorMap["disableTable"] = &hbaseProcessorDisableTable{handler: handler}
	self177.processorMap["isTableEnabled"] = &hbaseProcessorIsTableEnabled{handler: handler}
	self177.processorMap["compact"] = &hbaseProcessorCompact{handler: handler}
	self177.processorMap["majorCompact"] = &hbaseProcessorMajorCompact{handler: handler}
	self177.processorMap["getTableNames"] = &hbaseProcessorGetTableNames{handler: handler}
	self177.processorMap["getColumnDescriptors"] = &hbaseProcessorGetColumnDescriptors{handler: handler}
	self177.processorMap["getTableRegions"] = &hbaseProcessorGetTableRegions{handler: handler}
	self177.processorMap["createTable"] = &hbaseProcessorCreateTable{handler: handler}
	self177.processorMap["deleteTable"] = &hbaseProcessorDeleteTable{handler: handler}
	self177.processorMap["get"] = &hbaseProcessorGet{handler: handler}
	self177.processorMap["getVer"] = &hbaseProcessorGetVer{handler: handler}
	self177.processorMap["getVerTs"] = &hbaseProcessorGetVerTs{handler: handler}
	self177.processorMap["getRow"] = &hbaseProcessorGetRow{handler: handler}
	self177.processorMap["getRowWithColumns"] = &hbaseProcessorGetRowWithColumns{handler: handler}
	self177.processorMap["getRowTs"] = &hbaseProcessorGetRowTs{handler: handler}
	self177.processorMap["getRowWithColumnsTs"] = &hbaseProcessorGetRowWithColumnsTs{handler: handler}
	self177.processorMap["getRows"] = &hbaseProcessorGetRows{handler: handler}
	self177.processorMap["getRowsWithColumns"] = &hbaseProcessorGetRowsWithColumns{handler: handler}
	self177.processorMap["getRowsTs"] = &hbaseProcessorGetRowsTs{handler: handler}
	self177.processorMap["getRowsWithColumnsTs"] = &hbaseProcessorGetRowsWithColumnsTs{handler: handler}
	self177.processorMap["mutateRow"] = &hbaseProcessorMutateRow{handler: handler}
	self177.processorMap["mutateRowTs"] = &hbaseProcessorMutateRowTs{handler: handler}
	self177.processorMap["mutateRows"] = &hbaseProcessorMutateRows{handler: handler}
	self177.processorMap["mutateRowsTs"] = &hbaseProcessorMutateRowsTs{handler: handler}
	self177.processorMap["atomicIncrement"] = &hbaseProcessorAtomicIncrement{handler: handler}
	self177.processorMap["deleteAll"] = &hbaseProcessorDeleteAll{handler: handler}
	self177.processorMap["deleteAllTs"] = &hbaseProcessorDeleteAllTs{handler: handler}
	self177.processorMap["deleteAllRow"] = &hbaseProcessorDeleteAllRow{handler: handler}
	self177.processorMap["increment"] = &hbaseProcessorIncrement{handler: handler}
	self177.processorMap["incrementRows"] = &hbaseProcessorIncrementRows{handler: handler}
	self177.processorMap["deleteAllRowTs"] = &hbaseProcessorDeleteAllRowTs{handler: handler}
	self177.processorMap["scannerOpenWithScan"] = &hbaseProcessorScannerOpenWithScan{handler: handler}
	self177.processorMap["scannerOpen"] = &hbaseProcessorScannerOpen{handler: handler}
	self177.processorMap["scannerOpenWithStop"] = &hbaseProcessorScannerOpenWithStop{handler: handler}
	self177.processorMap["scannerOpenWithPrefix"] = &hbaseProcessorScannerOpenWithPrefix{handler: handler}
	self177.processorMap["scannerOpenTs"] = &hbaseProcessorScannerOpenTs{handler: handler}
	self177.processorMap["scannerOpenWithStopTs"] = &hbaseProcessorScannerOpenWithStopTs{handler: handler}
	self177.processorMap["scannerGet"] = &hbaseProcessorScannerGet{handler: handler}
	self177.processorMap["scannerGetList"] = &hbaseProcessorScannerGetList{handler: handler}
	self177.processorMap["scannerClose"] = &hbaseProcessorScannerClose{handler: handler}
	self177.processorMap["getRowOrBefore"] = &hbaseProcessorGetRowOrBefore{handler: handler}
	self177.processorMap["getRegionInfo"] = &hbaseProcessorGetRegionInfo{handler: handler}
	return self177
}

func (p *HbaseProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x178 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x178.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x178

}

type hbaseProcessorEnableTable struct {
	handler Hbase
}

func (p *hbaseProcessorEnableTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewEnableTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewEnableTableResult()
	var err2 error
	if err2 = p.handler.EnableTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enableTable: "+err2.Error())
			oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("enableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDisableTable struct {
	handler Hbase
}

func (p *hbaseProcessorDisableTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDisableTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewDisableTableResult()
	var err2 error
	if err2 = p.handler.DisableTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing disableTable: "+err2.Error())
			oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("disableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorIsTableEnabled struct {
	handler Hbase
}

func (p *hbaseProcessorIsTableEnabled) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewIsTableEnabledArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewIsTableEnabledResult()
	var err2 error
	if result.Success, err2 = p.handler.IsTableEnabled(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableEnabled: "+err2.Error())
			oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("isTableEnabled", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorCompact struct {
	handler Hbase
}

func (p *hbaseProcessorCompact) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCompactArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("compact", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewCompactResult()
	var err2 error
	if err2 = p.handler.Compact(args.TableNameOrRegionName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing compact: "+err2.Error())
			oprot.WriteMessageBegin("compact", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("compact", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMajorCompact struct {
	handler Hbase
}

func (p *hbaseProcessorMajorCompact) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMajorCompactArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("majorCompact", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewMajorCompactResult()
	var err2 error
	if err2 = p.handler.MajorCompact(args.TableNameOrRegionName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing majorCompact: "+err2.Error())
			oprot.WriteMessageBegin("majorCompact", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("majorCompact", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetTableNames struct {
	handler Hbase
}

func (p *hbaseProcessorGetTableNames) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetTableNamesArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableNames", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetTableNamesResult()
	var err2 error
	if result.Success, err2 = p.handler.GetTableNames(); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNames: "+err2.Error())
			oprot.WriteMessageBegin("getTableNames", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getTableNames", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetColumnDescriptors struct {
	handler Hbase
}

func (p *hbaseProcessorGetColumnDescriptors) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetColumnDescriptorsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getColumnDescriptors", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetColumnDescriptorsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetColumnDescriptors(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getColumnDescriptors: "+err2.Error())
			oprot.WriteMessageBegin("getColumnDescriptors", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getColumnDescriptors", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetTableRegions struct {
	handler Hbase
}

func (p *hbaseProcessorGetTableRegions) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetTableRegionsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableRegions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetTableRegionsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetTableRegions(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableRegions: "+err2.Error())
			oprot.WriteMessageBegin("getTableRegions", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getTableRegions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorCreateTable struct {
	handler Hbase
}

func (p *hbaseProcessorCreateTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCreateTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewCreateTableResult()
	var err2 error
	if err2 = p.handler.CreateTable(args.TableName, args.ColumnFamilies); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		case *AlreadyExists:
			result.Exist = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createTable: "+err2.Error())
			oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("createTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteTable struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewDeleteTableResult()
	var err2 error
	if err2 = p.handler.DeleteTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteTable: "+err2.Error())
			oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGet struct {
	handler Hbase
}

func (p *hbaseProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetResult()
	var err2 error
	if result.Success, err2 = p.handler.Get(args.TableName, args.Row, args.Column, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetVer struct {
	handler Hbase
}

func (p *hbaseProcessorGetVer) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetVerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getVer", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetVerResult()
	var err2 error
	if result.Success, err2 = p.handler.GetVer(args.TableName, args.Row, args.Column, args.NumVersions, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getVer: "+err2.Error())
			oprot.WriteMessageBegin("getVer", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getVer", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetVerTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetVerTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetVerTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getVerTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetVerTsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetVerTs(args.TableName, args.Row, args.Column, args.Timestamp, args.NumVersions, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getVerTs: "+err2.Error())
			oprot.WriteMessageBegin("getVerTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getVerTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRow struct {
	handler Hbase
}

func (p *hbaseProcessorGetRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRowResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRow(args.TableName, args.Row, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRow: "+err2.Error())
			oprot.WriteMessageBegin("getRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowWithColumns struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowWithColumns) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowWithColumnsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowWithColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRowWithColumnsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRowWithColumns(args.TableName, args.Row, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowWithColumns: "+err2.Error())
			oprot.WriteMessageBegin("getRowWithColumns", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRowWithColumns", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRowTsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRowTs(args.TableName, args.Row, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowTs: "+err2.Error())
			oprot.WriteMessageBegin("getRowTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRowTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowWithColumnsTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowWithColumnsTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowWithColumnsTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRowWithColumnsTsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRowWithColumnsTs(args.TableName, args.Row, args.Columns, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowWithColumnsTs: "+err2.Error())
			oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRows struct {
	handler Hbase
}

func (p *hbaseProcessorGetRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRowsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRows(args.TableName, args.Rows, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRows: "+err2.Error())
			oprot.WriteMessageBegin("getRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowsWithColumns struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowsWithColumns) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowsWithColumnsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowsWithColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRowsWithColumnsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRowsWithColumns(args.TableName, args.Rows, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowsWithColumns: "+err2.Error())
			oprot.WriteMessageBegin("getRowsWithColumns", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRowsWithColumns", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowsTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowsTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowsTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRowsTsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRowsTs(args.TableName, args.Rows, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowsTs: "+err2.Error())
			oprot.WriteMessageBegin("getRowsTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRowsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowsWithColumnsTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowsWithColumnsTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowsWithColumnsTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRowsWithColumnsTsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRowsWithColumnsTs(args.TableName, args.Rows, args.Columns, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowsWithColumnsTs: "+err2.Error())
			oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRow struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutateRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewMutateRowResult()
	var err2 error
	if err2 = p.handler.MutateRow(args.TableName, args.Row, args.Mutations, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRow: "+err2.Error())
			oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRowTs struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRowTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutateRowTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewMutateRowTsResult()
	var err2 error
	if err2 = p.handler.MutateRowTs(args.TableName, args.Row, args.Mutations, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRowTs: "+err2.Error())
			oprot.WriteMessageBegin("mutateRowTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRowTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRows struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutateRowsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewMutateRowsResult()
	var err2 error
	if err2 = p.handler.MutateRows(args.TableName, args.RowBatches, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRows: "+err2.Error())
			oprot.WriteMessageBegin("mutateRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRowsTs struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRowsTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutateRowsTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRowsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewMutateRowsTsResult()
	var err2 error
	if err2 = p.handler.MutateRowsTs(args.TableName, args.RowBatches, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRowsTs: "+err2.Error())
			oprot.WriteMessageBegin("mutateRowsTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRowsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorAtomicIncrement struct {
	handler Hbase
}

func (p *hbaseProcessorAtomicIncrement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAtomicIncrementArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("atomicIncrement", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewAtomicIncrementResult()
	var err2 error
	if result.Success, err2 = p.handler.AtomicIncrement(args.TableName, args.Row, args.Column, args.Value); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing atomicIncrement: "+err2.Error())
			oprot.WriteMessageBegin("atomicIncrement", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("atomicIncrement", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAll struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAll) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteAllArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAll", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewDeleteAllResult()
	var err2 error
	if err2 = p.handler.DeleteAll(args.TableName, args.Row, args.Column, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAll: "+err2.Error())
			oprot.WriteMessageBegin("deleteAll", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteAll", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAllTs struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAllTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteAllTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAllTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewDeleteAllTsResult()
	var err2 error
	if err2 = p.handler.DeleteAllTs(args.TableName, args.Row, args.Column, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAllTs: "+err2.Error())
			oprot.WriteMessageBegin("deleteAllTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteAllTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAllRow struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAllRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteAllRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAllRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewDeleteAllRowResult()
	var err2 error
	if err2 = p.handler.DeleteAllRow(args.TableName, args.Row, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAllRow: "+err2.Error())
			oprot.WriteMessageBegin("deleteAllRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteAllRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorIncrement struct {
	handler Hbase
}

func (p *hbaseProcessorIncrement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewIncrementArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewIncrementResult()
	var err2 error
	if err2 = p.handler.Increment(args.Increment); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: "+err2.Error())
			oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("increment", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorIncrementRows struct {
	handler Hbase
}

func (p *hbaseProcessorIncrementRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewIncrementRowsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("incrementRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewIncrementRowsResult()
	var err2 error
	if err2 = p.handler.IncrementRows(args.Increments); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing incrementRows: "+err2.Error())
			oprot.WriteMessageBegin("incrementRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("incrementRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAllRowTs struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAllRowTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteAllRowTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAllRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewDeleteAllRowTsResult()
	var err2 error
	if err2 = p.handler.DeleteAllRowTs(args.TableName, args.Row, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAllRowTs: "+err2.Error())
			oprot.WriteMessageBegin("deleteAllRowTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteAllRowTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithScan struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithScan) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenWithScanArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithScan", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewScannerOpenWithScanResult()
	var err2 error
	if result.Success, err2 = p.handler.ScannerOpenWithScan(args.TableName, args.Scan, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithScan: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenWithScan", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenWithScan", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpen struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpen) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpen", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewScannerOpenResult()
	var err2 error
	if result.Success, err2 = p.handler.ScannerOpen(args.TableName, args.StartRow, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpen: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpen", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerOpen", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithStop struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithStop) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenWithStopArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithStop", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewScannerOpenWithStopResult()
	var err2 error
	if result.Success, err2 = p.handler.ScannerOpenWithStop(args.TableName, args.StartRow, args.StopRow, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithStop: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenWithStop", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenWithStop", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithPrefix struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithPrefix) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenWithPrefixArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewScannerOpenWithPrefixResult()
	var err2 error
	if result.Success, err2 = p.handler.ScannerOpenWithPrefix(args.TableName, args.StartAndPrefix, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithPrefix: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenTs struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewScannerOpenTsResult()
	var err2 error
	if result.Success, err2 = p.handler.ScannerOpenTs(args.TableName, args.StartRow, args.Columns, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenTs: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithStopTs struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithStopTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenWithStopTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewScannerOpenWithStopTsResult()
	var err2 error
	if result.Success, err2 = p.handler.ScannerOpenWithStopTs(args.TableName, args.StartRow, args.StopRow, args.Columns, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithStopTs: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerGet struct {
	handler Hbase
}

func (p *hbaseProcessorScannerGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerGet", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewScannerGetResult()
	var err2 error
	if result.Success, err2 = p.handler.ScannerGet(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerGet: "+err2.Error())
			oprot.WriteMessageBegin("scannerGet", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerGet", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerGetList struct {
	handler Hbase
}

func (p *hbaseProcessorScannerGetList) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetListArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerGetList", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewScannerGetListResult()
	var err2 error
	if result.Success, err2 = p.handler.ScannerGetList(args.Id, args.NbRows); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerGetList: "+err2.Error())
			oprot.WriteMessageBegin("scannerGetList", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerGetList", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerClose struct {
	handler Hbase
}

func (p *hbaseProcessorScannerClose) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerCloseArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerClose", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewScannerCloseResult()
	var err2 error
	if err2 = p.handler.ScannerClose(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerClose: "+err2.Error())
			oprot.WriteMessageBegin("scannerClose", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerClose", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowOrBefore struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowOrBefore) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowOrBeforeArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowOrBefore", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRowOrBeforeResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRowOrBefore(args.TableName, args.Row, args.Family); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowOrBefore: "+err2.Error())
			oprot.WriteMessageBegin("getRowOrBefore", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRowOrBefore", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRegionInfo struct {
	handler Hbase
}

func (p *hbaseProcessorGetRegionInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRegionInfoArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRegionInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetRegionInfoResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRegionInfo(args.Row); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRegionInfo: "+err2.Error())
			oprot.WriteMessageBegin("getRegionInfo", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getRegionInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type EnableTableArgs struct {
	TableName Bytes `thrift:"tableName,1"`
}

func NewEnableTableArgs() *EnableTableArgs {
	rval := &EnableTableArgs{}
	return rval
}

func (p *EnableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EnableTableArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableName = temp
	}
	return nil
}

func (p *EnableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EnableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *EnableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EnableTableArgs(%+v)", *p)
}

type EnableTableResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewEnableTableResult() *EnableTableResult {
	rval := &EnableTableResult{}
	return rval
}

func (p *EnableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EnableTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *EnableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EnableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *EnableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EnableTableResult(%+v)", *p)
}

type DisableTableArgs struct {
	TableName Bytes `thrift:"tableName,1"`
}

func NewDisableTableArgs() *DisableTableArgs {
	rval := &DisableTableArgs{}
	return rval
}

func (p *DisableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DisableTableArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableName = temp
	}
	return nil
}

func (p *DisableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DisableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DisableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DisableTableArgs(%+v)", *p)
}

type DisableTableResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDisableTableResult() *DisableTableResult {
	rval := &DisableTableResult{}
	return rval
}

func (p *DisableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DisableTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DisableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DisableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DisableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DisableTableResult(%+v)", *p)
}

type IsTableEnabledArgs struct {
	TableName Bytes `thrift:"tableName,1"`
}

func NewIsTableEnabledArgs() *IsTableEnabledArgs {
	rval := &IsTableEnabledArgs{}
	return rval
}

func (p *IsTableEnabledArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableEnabledArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableName = temp
	}
	return nil
}

func (p *IsTableEnabledArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableEnabledArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *IsTableEnabledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableEnabledArgs(%+v)", *p)
}

type IsTableEnabledResult struct {
	Success bool     `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewIsTableEnabledResult() *IsTableEnabledResult {
	rval := &IsTableEnabledResult{}
	return rval
}

func (p *IsTableEnabledResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableEnabledResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *IsTableEnabledResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IsTableEnabledResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableEnabledResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *IsTableEnabledResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IsTableEnabledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableEnabledResult(%+v)", *p)
}

type CompactArgs struct {
	TableNameOrRegionName Bytes `thrift:"tableNameOrRegionName,1"`
}

func NewCompactArgs() *CompactArgs {
	rval := &CompactArgs{}
	return rval
}

func (p *CompactArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompactArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableNameOrRegionName = temp
	}
	return nil
}

func (p *CompactArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("compact_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CompactArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableNameOrRegionName != nil {
		if err := oprot.WriteFieldBegin("tableNameOrRegionName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableNameOrRegionName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableNameOrRegionName); err != nil {
			return fmt.Errorf("%T.tableNameOrRegionName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableNameOrRegionName: %s", p, err)
		}
	}
	return err
}

func (p *CompactArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompactArgs(%+v)", *p)
}

type CompactResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewCompactResult() *CompactResult {
	rval := &CompactResult{}
	return rval
}

func (p *CompactResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompactResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CompactResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("compact_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CompactResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CompactResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompactResult(%+v)", *p)
}

type MajorCompactArgs struct {
	TableNameOrRegionName Bytes `thrift:"tableNameOrRegionName,1"`
}

func NewMajorCompactArgs() *MajorCompactArgs {
	rval := &MajorCompactArgs{}
	return rval
}

func (p *MajorCompactArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MajorCompactArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableNameOrRegionName = temp
	}
	return nil
}

func (p *MajorCompactArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("majorCompact_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MajorCompactArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableNameOrRegionName != nil {
		if err := oprot.WriteFieldBegin("tableNameOrRegionName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableNameOrRegionName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableNameOrRegionName); err != nil {
			return fmt.Errorf("%T.tableNameOrRegionName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableNameOrRegionName: %s", p, err)
		}
	}
	return err
}

func (p *MajorCompactArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MajorCompactArgs(%+v)", *p)
}

type MajorCompactResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewMajorCompactResult() *MajorCompactResult {
	rval := &MajorCompactResult{}
	return rval
}

func (p *MajorCompactResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MajorCompactResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MajorCompactResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("majorCompact_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MajorCompactResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MajorCompactResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MajorCompactResult(%+v)", *p)
}

type GetTableNamesArgs struct {
}

func NewGetTableNamesArgs() *GetTableNamesArgs {
	rval := &GetTableNamesArgs{}
	return rval
}

func (p *GetTableNamesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNames_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesArgs(%+v)", *p)
}

type GetTableNamesResult struct {
	Success []Text   `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetTableNamesResult() *GetTableNamesResult {
	rval := &GetTableNamesResult{}
	return rval
}

func (p *GetTableNamesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem179 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem179 = temp
		}
		p.Success = append(p.Success, _elem179)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableNamesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableNamesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNames_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesResult(%+v)", *p)
}

type GetColumnDescriptorsArgs struct {
	TableName Text `thrift:"tableName,1"`
}

func NewGetColumnDescriptorsArgs() *GetColumnDescriptorsArgs {
	rval := &GetColumnDescriptorsArgs{}
	return rval
}

func (p *GetColumnDescriptorsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetColumnDescriptorsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetColumnDescriptorsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getColumnDescriptors_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetColumnDescriptorsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetColumnDescriptorsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetColumnDescriptorsArgs(%+v)", *p)
}

type GetColumnDescriptorsResult struct {
	Success map[string]*ColumnDescriptor `thrift:"success,0"`
	Io      *IOError                     `thrift:"io,1"`
}

func NewGetColumnDescriptorsResult() *GetColumnDescriptorsResult {
	rval := &GetColumnDescriptorsResult{}
	return rval
}

func (p *GetColumnDescriptorsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]*ColumnDescriptor, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key180 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key180 = string(temp)
		}
		_val181 := NewColumnDescriptor()
		if err := _val181.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _val181, err)
		}
		p.Success[_key180] = _val181
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getColumnDescriptors_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetColumnDescriptorsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetColumnDescriptorsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetColumnDescriptorsResult(%+v)", *p)
}

type GetTableRegionsArgs struct {
	TableName Text `thrift:"tableName,1"`
}

func NewGetTableRegionsArgs() *GetTableRegionsArgs {
	rval := &GetTableRegionsArgs{}
	return rval
}

func (p *GetTableRegionsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableRegionsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetTableRegionsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableRegions_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableRegionsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetTableRegionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableRegionsArgs(%+v)", *p)
}

type GetTableRegionsResult struct {
	Success []*TRegionInfo `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetTableRegionsResult() *GetTableRegionsResult {
	rval := &GetTableRegionsResult{}
	return rval
}

func (p *GetTableRegionsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableRegionsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRegionInfo, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem182 := NewTRegionInfo()
		if err := _elem182.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem182, err)
		}
		p.Success = append(p.Success, _elem182)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableRegionsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableRegionsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableRegions_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableRegionsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableRegionsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableRegionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableRegionsResult(%+v)", *p)
}

type CreateTableArgs struct {
	TableName      Text                `thrift:"tableName,1"`
	ColumnFamilies []*ColumnDescriptor `thrift:"columnFamilies,2"`
}

func NewCreateTableArgs() *CreateTableArgs {
	rval := &CreateTableArgs{}
	return rval
}

func (p *CreateTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *CreateTableArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*ColumnDescriptor, 0, size)
	p.ColumnFamilies = tSlice
	for i := 0; i < size; i++ {
		_elem183 := NewColumnDescriptor()
		if err := _elem183.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem183, err)
		}
		p.ColumnFamilies = append(p.ColumnFamilies, _elem183)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CreateTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnFamilies != nil {
		if err := oprot.WriteFieldBegin("columnFamilies", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columnFamilies: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnFamilies)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.ColumnFamilies {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columnFamilies: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableArgs(%+v)", *p)
}

type CreateTableResult struct {
	Io    *IOError         `thrift:"io,1"`
	Ia    *IllegalArgument `thrift:"ia,2"`
	Exist *AlreadyExists   `thrift:"exist,3"`
}

func NewCreateTableResult() *CreateTableResult {
	rval := &CreateTableResult{}
	return rval
}

func (p *CreateTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CreateTableResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *CreateTableResult) ReadField3(iprot thrift.TProtocol) error {
	p.Exist = NewAlreadyExists()
	if err := p.Exist.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Exist, err)
	}
	return nil
}

func (p *CreateTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Exist != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Exist != nil {
		if err := oprot.WriteFieldBegin("exist", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:exist: %s", p, err)
		}
		if err := p.Exist.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Exist, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:exist: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableResult(%+v)", *p)
}

type DeleteTableArgs struct {
	TableName Text `thrift:"tableName,1"`
}

func NewDeleteTableArgs() *DeleteTableArgs {
	rval := &DeleteTableArgs{}
	return rval
}

func (p *DeleteTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTableArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTableArgs(%+v)", *p)
}

type DeleteTableResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteTableResult() *DeleteTableResult {
	rval := &DeleteTableResult{}
	return rval
}

func (p *DeleteTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTableResult(%+v)", *p)
}

type GetArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Column     Text            `thrift:"column,3"`
	Attributes map[string]Text `thrift:"attributes,4"`
}

func NewGetArgs() *GetArgs {
	rval := &GetArgs{}
	return rval
}

func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *GetArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key184 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key184 = string(temp)
		}
		var _val185 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val185 = temp
		}
		p.Attributes[_key184] = _val185
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success []*TCell `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetResult() *GetResult {
	rval := &GetResult{}
	return rval
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TCell, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem186 := NewTCell()
		if err := _elem186.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem186, err)
		}
		p.Success = append(p.Success, _elem186)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type GetVerArgs struct {
	TableName   Text            `thrift:"tableName,1"`
	Row         Text            `thrift:"row,2"`
	Column      Text            `thrift:"column,3"`
	NumVersions int32           `thrift:"numVersions,4"`
	Attributes  map[string]Text `thrift:"attributes,5"`
}

func NewGetVerArgs() *GetVerArgs {
	rval := &GetVerArgs{}
	return rval
}

func (p *GetVerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetVerArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetVerArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *GetVerArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.NumVersions = v
	}
	return nil
}

func (p *GetVerArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key187 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key187 = string(temp)
		}
		var _val188 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val188 = temp
		}
		p.Attributes[_key187] = _val188
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetVerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVer_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetVerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetVerArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *GetVerArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numVersions", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:numVersions: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumVersions)); err != nil {
		return fmt.Errorf("%T.numVersions (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:numVersions: %s", p, err)
	}
	return err
}

func (p *GetVerArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetVerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerArgs(%+v)", *p)
}

type GetVerResult struct {
	Success []*TCell `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetVerResult() *GetVerResult {
	rval := &GetVerResult{}
	return rval
}

func (p *GetVerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TCell, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem189 := NewTCell()
		if err := _elem189.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem189, err)
		}
		p.Success = append(p.Success, _elem189)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetVerResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetVerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVer_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetVerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetVerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerResult(%+v)", *p)
}

type GetVerTsArgs struct {
	TableName   Text            `thrift:"tableName,1"`
	Row         Text            `thrift:"row,2"`
	Column      Text            `thrift:"column,3"`
	Timestamp   int64           `thrift:"timestamp,4"`
	NumVersions int32           `thrift:"numVersions,5"`
	Attributes  map[string]Text `thrift:"attributes,6"`
}

func NewGetVerTsArgs() *GetVerTsArgs {
	rval := &GetVerTsArgs{}
	return rval
}

func (p *GetVerTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetVerTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetVerTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *GetVerTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetVerTsArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.NumVersions = v
	}
	return nil
}

func (p *GetVerTsArgs) ReadField6(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key190 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key190 = string(temp)
		}
		var _val191 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val191 = temp
		}
		p.Attributes[_key190] = _val191
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetVerTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVerTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numVersions", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:numVersions: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumVersions)); err != nil {
		return fmt.Errorf("%T.numVersions (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:numVersions: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerTsArgs(%+v)", *p)
}

type GetVerTsResult struct {
	Success []*TCell `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetVerTsResult() *GetVerTsResult {
	rval := &GetVerTsResult{}
	return rval
}

func (p *GetVerTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TCell, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem192 := NewTCell()
		if err := _elem192.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem192, err)
		}
		p.Success = append(p.Success, _elem192)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetVerTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetVerTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVerTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerTsResult(%+v)", *p)
}

type GetRowArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Attributes map[string]Text `thrift:"attributes,3"`
}

func NewGetRowArgs() *GetRowArgs {
	rval := &GetRowArgs{}
	return rval
}

func (p *GetRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key193 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key193 = string(temp)
		}
		var _val194 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val194 = temp
		}
		p.Attributes[_key193] = _val194
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowArgs(%+v)", *p)
}

type GetRowResult struct {
	Success []*TRowResult_ `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetRowResult() *GetRowResult {
	rval := &GetRowResult{}
	return rval
}

func (p *GetRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem195 := NewTRowResult_()
		if err := _elem195.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem195, err)
		}
		p.Success = append(p.Success, _elem195)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowResult(%+v)", *p)
}

type GetRowWithColumnsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Columns    []Text          `thrift:"columns,3"`
	Attributes map[string]Text `thrift:"attributes,4"`
}

func NewGetRowWithColumnsArgs() *GetRowWithColumnsArgs {
	rval := &GetRowWithColumnsArgs{}
	return rval
}

func (p *GetRowWithColumnsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowWithColumnsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowWithColumnsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem196 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem196 = temp
		}
		p.Columns = append(p.Columns, _elem196)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key197 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key197 = string(temp)
		}
		var _val198 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val198 = temp
		}
		p.Attributes[_key197] = _val198
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumns_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsArgs(%+v)", *p)
}

type GetRowWithColumnsResult struct {
	Success []*TRowResult_ `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetRowWithColumnsResult() *GetRowWithColumnsResult {
	rval := &GetRowWithColumnsResult{}
	return rval
}

func (p *GetRowWithColumnsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem199 := NewTRowResult_()
		if err := _elem199.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem199, err)
		}
		p.Success = append(p.Success, _elem199)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumns_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsResult(%+v)", *p)
}

type GetRowTsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Timestamp  int64           `thrift:"timestamp,3"`
	Attributes map[string]Text `thrift:"attributes,4"`
}

func NewGetRowTsArgs() *GetRowTsArgs {
	rval := &GetRowTsArgs{}
	return rval
}

func (p *GetRowTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key200 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key200 = string(temp)
		}
		var _val201 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val201 = temp
		}
		p.Attributes[_key200] = _val201
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowTsArgs(%+v)", *p)
}

type GetRowTsResult struct {
	Success []*TRowResult_ `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetRowTsResult() *GetRowTsResult {
	rval := &GetRowTsResult{}
	return rval
}

func (p *GetRowTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem202 := NewTRowResult_()
		if err := _elem202.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem202, err)
		}
		p.Success = append(p.Success, _elem202)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowTsResult(%+v)", *p)
}

type GetRowWithColumnsTsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Columns    []Text          `thrift:"columns,3"`
	Timestamp  int64           `thrift:"timestamp,4"`
	Attributes map[string]Text `thrift:"attributes,5"`
}

func NewGetRowWithColumnsTsArgs() *GetRowWithColumnsTsArgs {
	rval := &GetRowWithColumnsTsArgs{}
	return rval
}

func (p *GetRowWithColumnsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem203 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem203 = temp
		}
		p.Columns = append(p.Columns, _elem203)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key204 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key204 = string(temp)
		}
		var _val205 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val205 = temp
		}
		p.Attributes[_key204] = _val205
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsTsArgs(%+v)", *p)
}

type GetRowWithColumnsTsResult struct {
	Success []*TRowResult_ `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetRowWithColumnsTsResult() *GetRowWithColumnsTsResult {
	rval := &GetRowWithColumnsTsResult{}
	return rval
}

func (p *GetRowWithColumnsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem206 := NewTRowResult_()
		if err := _elem206.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem206, err)
		}
		p.Success = append(p.Success, _elem206)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsTsResult(%+v)", *p)
}

type GetRowsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Rows       []Text          `thrift:"rows,2"`
	Attributes map[string]Text `thrift:"attributes,3"`
}

func NewGetRowsArgs() *GetRowsArgs {
	rval := &GetRowsArgs{}
	return rval
}

func (p *GetRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		var _elem207 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem207 = temp
		}
		p.Rows = append(p.Rows, _elem207)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key208 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key208 = string(temp)
		}
		var _val209 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val209 = temp
		}
		p.Attributes[_key208] = _val209
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Rows)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Rows {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsArgs(%+v)", *p)
}

type GetRowsResult struct {
	Success []*TRowResult_ `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetRowsResult() *GetRowsResult {
	rval := &GetRowsResult{}
	return rval
}

func (p *GetRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem210 := NewTRowResult_()
		if err := _elem210.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem210, err)
		}
		p.Success = append(p.Success, _elem210)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsResult(%+v)", *p)
}

type GetRowsWithColumnsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Rows       []Text          `thrift:"rows,2"`
	Columns    []Text          `thrift:"columns,3"`
	Attributes map[string]Text `thrift:"attributes,4"`
}

func NewGetRowsWithColumnsArgs() *GetRowsWithColumnsArgs {
	rval := &GetRowsWithColumnsArgs{}
	return rval
}

func (p *GetRowsWithColumnsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		var _elem211 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem211 = temp
		}
		p.Rows = append(p.Rows, _elem211)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem212 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem212 = temp
		}
		p.Columns = append(p.Columns, _elem212)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key213 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key213 = string(temp)
		}
		var _val214 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val214 = temp
		}
		p.Attributes[_key213] = _val214
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumns_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Rows)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Rows {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsArgs(%+v)", *p)
}

type GetRowsWithColumnsResult struct {
	Success []*TRowResult_ `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetRowsWithColumnsResult() *GetRowsWithColumnsResult {
	rval := &GetRowsWithColumnsResult{}
	return rval
}

func (p *GetRowsWithColumnsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem215 := NewTRowResult_()
		if err := _elem215.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem215, err)
		}
		p.Success = append(p.Success, _elem215)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumns_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsResult(%+v)", *p)
}

type GetRowsTsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Rows       []Text          `thrift:"rows,2"`
	Timestamp  int64           `thrift:"timestamp,3"`
	Attributes map[string]Text `thrift:"attributes,4"`
}

func NewGetRowsTsArgs() *GetRowsTsArgs {
	rval := &GetRowsTsArgs{}
	return rval
}

func (p *GetRowsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowsTsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		var _elem216 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem216 = temp
		}
		p.Rows = append(p.Rows, _elem216)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowsTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key217 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key217 = string(temp)
		}
		var _val218 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val218 = temp
		}
		p.Attributes[_key217] = _val218
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Rows)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Rows {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsTsArgs(%+v)", *p)
}

type GetRowsTsResult struct {
	Success []*TRowResult_ `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetRowsTsResult() *GetRowsTsResult {
	rval := &GetRowsTsResult{}
	return rval
}

func (p *GetRowsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem219 := NewTRowResult_()
		if err := _elem219.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem219, err)
		}
		p.Success = append(p.Success, _elem219)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsTsResult(%+v)", *p)
}

type GetRowsWithColumnsTsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Rows       []Text          `thrift:"rows,2"`
	Columns    []Text          `thrift:"columns,3"`
	Timestamp  int64           `thrift:"timestamp,4"`
	Attributes map[string]Text `thrift:"attributes,5"`
}

func NewGetRowsWithColumnsTsArgs() *GetRowsWithColumnsTsArgs {
	rval := &GetRowsWithColumnsTsArgs{}
	return rval
}

func (p *GetRowsWithColumnsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		var _elem220 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem220 = temp
		}
		p.Rows = append(p.Rows, _elem220)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem221 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem221 = temp
		}
		p.Columns = append(p.Columns, _elem221)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key222 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key222 = string(temp)
		}
		var _val223 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val223 = temp
		}
		p.Attributes[_key222] = _val223
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumnsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Rows)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Rows {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsTsArgs(%+v)", *p)
}

type GetRowsWithColumnsTsResult struct {
	Success []*TRowResult_ `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetRowsWithColumnsTsResult() *GetRowsWithColumnsTsResult {
	rval := &GetRowsWithColumnsTsResult{}
	return rval
}

func (p *GetRowsWithColumnsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem224 := NewTRowResult_()
		if err := _elem224.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem224, err)
		}
		p.Success = append(p.Success, _elem224)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumnsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsTsResult(%+v)", *p)
}

type MutateRowArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Mutations  []*Mutation     `thrift:"mutations,3"`
	Attributes map[string]Text `thrift:"attributes,4"`
}

func NewMutateRowArgs() *MutateRowArgs {
	rval := &MutateRowArgs{}
	return rval
}

func (p *MutateRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *MutateRowArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *MutateRowArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Mutation, 0, size)
	p.Mutations = tSlice
	for i := 0; i < size; i++ {
		_elem225 := NewMutation()
		if err := _elem225.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem225, err)
		}
		p.Mutations = append(p.Mutations, _elem225)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key226 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key226 = string(temp)
		}
		var _val227 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val227 = temp
		}
		p.Attributes[_key226] = _val227
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Mutations != nil {
		if err := oprot.WriteFieldBegin("mutations", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutations: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Mutations)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Mutations {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutations: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowArgs(%+v)", *p)
}

type MutateRowResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMutateRowResult() *MutateRowResult {
	rval := &MutateRowResult{}
	return rval
}

func (p *MutateRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *MutateRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowResult(%+v)", *p)
}

type MutateRowTsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Mutations  []*Mutation     `thrift:"mutations,3"`
	Timestamp  int64           `thrift:"timestamp,4"`
	Attributes map[string]Text `thrift:"attributes,5"`
}

func NewMutateRowTsArgs() *MutateRowTsArgs {
	rval := &MutateRowTsArgs{}
	return rval
}

func (p *MutateRowTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Mutation, 0, size)
	p.Mutations = tSlice
	for i := 0; i < size; i++ {
		_elem228 := NewMutation()
		if err := _elem228.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem228, err)
		}
		p.Mutations = append(p.Mutations, _elem228)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key229 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key229 = string(temp)
		}
		var _val230 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val230 = temp
		}
		p.Attributes[_key229] = _val230
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MutateRowTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Mutations != nil {
		if err := oprot.WriteFieldBegin("mutations", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutations: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Mutations)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Mutations {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutations: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *MutateRowTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowTsArgs(%+v)", *p)
}

type MutateRowTsResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMutateRowTsResult() *MutateRowTsResult {
	rval := &MutateRowTsResult{}
	return rval
}

func (p *MutateRowTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowTsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *MutateRowTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowTsResult(%+v)", *p)
}

type MutateRowsArgs struct {
	TableName  Text             `thrift:"tableName,1"`
	RowBatches []*BatchMutation `thrift:"rowBatches,2"`
	Attributes map[string]Text  `thrift:"attributes,3"`
}

func NewMutateRowsArgs() *MutateRowsArgs {
	rval := &MutateRowsArgs{}
	return rval
}

func (p *MutateRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *MutateRowsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*BatchMutation, 0, size)
	p.RowBatches = tSlice
	for i := 0; i < size; i++ {
		_elem231 := NewBatchMutation()
		if err := _elem231.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem231, err)
		}
		p.RowBatches = append(p.RowBatches, _elem231)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MutateRowsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key232 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key232 = string(temp)
		}
		var _val233 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val233 = temp
		}
		p.Attributes[_key232] = _val233
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MutateRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.RowBatches != nil {
		if err := oprot.WriteFieldBegin("rowBatches", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rowBatches: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowBatches)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.RowBatches {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rowBatches: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsArgs(%+v)", *p)
}

type MutateRowsResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMutateRowsResult() *MutateRowsResult {
	rval := &MutateRowsResult{}
	return rval
}

func (p *MutateRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *MutateRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsResult(%+v)", *p)
}

type MutateRowsTsArgs struct {
	TableName  Text             `thrift:"tableName,1"`
	RowBatches []*BatchMutation `thrift:"rowBatches,2"`
	Timestamp  int64            `thrift:"timestamp,3"`
	Attributes map[string]Text  `thrift:"attributes,4"`
}

func NewMutateRowsTsArgs() *MutateRowsTsArgs {
	rval := &MutateRowsTsArgs{}
	return rval
}

func (p *MutateRowsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *MutateRowsTsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*BatchMutation, 0, size)
	p.RowBatches = tSlice
	for i := 0; i < size; i++ {
		_elem234 := NewBatchMutation()
		if err := _elem234.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem234, err)
		}
		p.RowBatches = append(p.RowBatches, _elem234)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MutateRowsTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *MutateRowsTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key235 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key235 = string(temp)
		}
		var _val236 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val236 = temp
		}
		p.Attributes[_key235] = _val236
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MutateRowsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.RowBatches != nil {
		if err := oprot.WriteFieldBegin("rowBatches", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rowBatches: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowBatches)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.RowBatches {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rowBatches: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *MutateRowsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsTsArgs(%+v)", *p)
}

type MutateRowsTsResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMutateRowsTsResult() *MutateRowsTsResult {
	rval := &MutateRowsTsResult{}
	return rval
}

func (p *MutateRowsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowsTsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *MutateRowsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsTsResult(%+v)", *p)
}

type AtomicIncrementArgs struct {
	TableName Text  `thrift:"tableName,1"`
	Row       Text  `thrift:"row,2"`
	Column    Text  `thrift:"column,3"`
	Value     int64 `thrift:"value,4"`
}

func NewAtomicIncrementArgs() *AtomicIncrementArgs {
	rval := &AtomicIncrementArgs{}
	return rval
}

func (p *AtomicIncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicIncrementArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *AtomicIncrementArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *AtomicIncrementArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *AtomicIncrementArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *AtomicIncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomicIncrement_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicIncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:value: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Value)); err != nil {
		return fmt.Errorf("%T.value (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:value: %s", p, err)
	}
	return err
}

func (p *AtomicIncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicIncrementArgs(%+v)", *p)
}

type AtomicIncrementResult struct {
	Success int64            `thrift:"success,0"`
	Io      *IOError         `thrift:"io,1"`
	Ia      *IllegalArgument `thrift:"ia,2"`
}

func NewAtomicIncrementResult() *AtomicIncrementResult {
	rval := &AtomicIncrementResult{}
	return rval
}

func (p *AtomicIncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicIncrementResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *AtomicIncrementResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *AtomicIncrementResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *AtomicIncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomicIncrement_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicIncrementResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *AtomicIncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicIncrementResult(%+v)", *p)
}

type DeleteAllArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Column     Text            `thrift:"column,3"`
	Attributes map[string]Text `thrift:"attributes,4"`
}

func NewDeleteAllArgs() *DeleteAllArgs {
	rval := &DeleteAllArgs{}
	return rval
}

func (p *DeleteAllArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteAllArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *DeleteAllArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *DeleteAllArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key237 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key237 = string(temp)
		}
		var _val238 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val238 = temp
		}
		p.Attributes[_key237] = _val238
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DeleteAllArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAll_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllArgs(%+v)", *p)
}

type DeleteAllResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteAllResult() *DeleteAllResult {
	rval := &DeleteAllResult{}
	return rval
}

func (p *DeleteAllResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteAllResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAll_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllResult(%+v)", *p)
}

type DeleteAllTsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Column     Text            `thrift:"column,3"`
	Timestamp  int64           `thrift:"timestamp,4"`
	Attributes map[string]Text `thrift:"attributes,5"`
}

func NewDeleteAllTsArgs() *DeleteAllTsArgs {
	rval := &DeleteAllTsArgs{}
	return rval
}

func (p *DeleteAllTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key239 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key239 = string(temp)
		}
		var _val240 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val240 = temp
		}
		p.Attributes[_key239] = _val240
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DeleteAllTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *DeleteAllTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllTsArgs(%+v)", *p)
}

type DeleteAllTsResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteAllTsResult() *DeleteAllTsResult {
	rval := &DeleteAllTsResult{}
	return rval
}

func (p *DeleteAllTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteAllTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllTsResult(%+v)", *p)
}

type DeleteAllRowArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Attributes map[string]Text `thrift:"attributes,3"`
}

func NewDeleteAllRowArgs() *DeleteAllRowArgs {
	rval := &DeleteAllRowArgs{}
	return rval
}

func (p *DeleteAllRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteAllRowArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *DeleteAllRowArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key241 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key241 = string(temp)
		}
		var _val242 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val242 = temp
		}
		p.Attributes[_key241] = _val242
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DeleteAllRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowArgs(%+v)", *p)
}

type DeleteAllRowResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteAllRowResult() *DeleteAllRowResult {
	rval := &DeleteAllRowResult{}
	return rval
}

func (p *DeleteAllRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteAllRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowResult(%+v)", *p)
}

type IncrementArgs struct {
	Increment *TIncrement `thrift:"increment,1"`
}

func NewIncrementArgs() *IncrementArgs {
	rval := &IncrementArgs{}
	return rval
}

func (p *IncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Increment = NewTIncrement()
	if err := p.Increment.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Increment, err)
	}
	return nil
}

func (p *IncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Increment != nil {
		if err := oprot.WriteFieldBegin("increment", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:increment: %s", p, err)
		}
		if err := p.Increment.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Increment, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:increment: %s", p, err)
		}
	}
	return err
}

func (p *IncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementArgs(%+v)", *p)
}

type IncrementResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewIncrementResult() *IncrementResult {
	rval := &IncrementResult{}
	return rval
}

func (p *IncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementResult(%+v)", *p)
}

type IncrementRowsArgs struct {
	Increments []*TIncrement `thrift:"increments,1"`
}

func NewIncrementRowsArgs() *IncrementRowsArgs {
	rval := &IncrementRowsArgs{}
	return rval
}

func (p *IncrementRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementRowsArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TIncrement, 0, size)
	p.Increments = tSlice
	for i := 0; i < size; i++ {
		_elem243 := NewTIncrement()
		if err := _elem243.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem243, err)
		}
		p.Increments = append(p.Increments, _elem243)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *IncrementRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("incrementRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Increments != nil {
		if err := oprot.WriteFieldBegin("increments", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:increments: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Increments)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Increments {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:increments: %s", p, err)
		}
	}
	return err
}

func (p *IncrementRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementRowsArgs(%+v)", *p)
}

type IncrementRowsResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewIncrementRowsResult() *IncrementRowsResult {
	rval := &IncrementRowsResult{}
	return rval
}

func (p *IncrementRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementRowsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IncrementRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("incrementRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IncrementRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementRowsResult(%+v)", *p)
}

type DeleteAllRowTsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Row        Text            `thrift:"row,2"`
	Timestamp  int64           `thrift:"timestamp,3"`
	Attributes map[string]Text `thrift:"attributes,4"`
}

func NewDeleteAllRowTsArgs() *DeleteAllRowTsArgs {
	rval := &DeleteAllRowTsArgs{}
	return rval
}

func (p *DeleteAllRowTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteAllRowTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *DeleteAllRowTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *DeleteAllRowTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key244 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key244 = string(temp)
		}
		var _val245 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val245 = temp
		}
		p.Attributes[_key244] = _val245
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRowTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *DeleteAllRowTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowTsArgs(%+v)", *p)
}

type DeleteAllRowTsResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteAllRowTsResult() *DeleteAllRowTsResult {
	rval := &DeleteAllRowTsResult{}
	return rval
}

func (p *DeleteAllRowTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteAllRowTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRowTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowTsResult(%+v)", *p)
}

type ScannerOpenWithScanArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	Scan       *TScan          `thrift:"scan,2"`
	Attributes map[string]Text `thrift:"attributes,3"`
}

func NewScannerOpenWithScanArgs() *ScannerOpenWithScanArgs {
	rval := &ScannerOpenWithScanArgs{}
	return rval
}

func (p *ScannerOpenWithScanArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Scan = NewTScan()
	if err := p.Scan.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Scan, err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key246 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key246 = string(temp)
		}
		var _val247 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val247 = temp
		}
		p.Attributes[_key246] = _val247
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithScan_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Scan != nil {
		if err := oprot.WriteFieldBegin("scan", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:scan: %s", p, err)
		}
		if err := p.Scan.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Scan, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:scan: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithScanArgs(%+v)", *p)
}

type ScannerOpenWithScanResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenWithScanResult() *ScannerOpenWithScanResult {
	rval := &ScannerOpenWithScanResult{}
	return rval
}

func (p *ScannerOpenWithScanResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = temp
	}
	return nil
}

func (p *ScannerOpenWithScanResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithScan_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithScanResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithScanResult(%+v)", *p)
}

type ScannerOpenArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	StartRow   Text            `thrift:"startRow,2"`
	Columns    []Text          `thrift:"columns,3"`
	Attributes map[string]Text `thrift:"attributes,4"`
}

func NewScannerOpenArgs() *ScannerOpenArgs {
	rval := &ScannerOpenArgs{}
	return rval
}

func (p *ScannerOpenArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartRow = temp
	}
	return nil
}

func (p *ScannerOpenArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem248 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem248 = temp
		}
		p.Columns = append(p.Columns, _elem248)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key249 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key249 = string(temp)
		}
		var _val250 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val250 = temp
		}
		p.Attributes[_key249] = _val250
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpen_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartRow != nil {
		if err := oprot.WriteFieldBegin("startRow", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartRow); err != nil {
			return fmt.Errorf("%T.startRow (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenArgs(%+v)", *p)
}

type ScannerOpenResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenResult() *ScannerOpenResult {
	rval := &ScannerOpenResult{}
	return rval
}

func (p *ScannerOpenResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = temp
	}
	return nil
}

func (p *ScannerOpenResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpen_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenResult(%+v)", *p)
}

type ScannerOpenWithStopArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	StartRow   Text            `thrift:"startRow,2"`
	StopRow    Text            `thrift:"stopRow,3"`
	Columns    []Text          `thrift:"columns,4"`
	Attributes map[string]Text `thrift:"attributes,5"`
}

func NewScannerOpenWithStopArgs() *ScannerOpenWithStopArgs {
	rval := &ScannerOpenWithStopArgs{}
	return rval
}

func (p *ScannerOpenWithStopArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartRow = temp
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.StopRow = temp
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem251 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem251 = temp
		}
		p.Columns = append(p.Columns, _elem251)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key252 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key252 = string(temp)
		}
		var _val253 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val253 = temp
		}
		p.Attributes[_key252] = _val253
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStop_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartRow != nil {
		if err := oprot.WriteFieldBegin("startRow", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartRow); err != nil {
			return fmt.Errorf("%T.startRow (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.StopRow != nil {
		if err := oprot.WriteFieldBegin("stopRow", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:stopRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StopRow); err != nil {
			return fmt.Errorf("%T.stopRow (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:stopRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopArgs(%+v)", *p)
}

type ScannerOpenWithStopResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenWithStopResult() *ScannerOpenWithStopResult {
	rval := &ScannerOpenWithStopResult{}
	return rval
}

func (p *ScannerOpenWithStopResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = temp
	}
	return nil
}

func (p *ScannerOpenWithStopResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStop_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopResult(%+v)", *p)
}

type ScannerOpenWithPrefixArgs struct {
	TableName      Text            `thrift:"tableName,1"`
	StartAndPrefix Text            `thrift:"startAndPrefix,2"`
	Columns        []Text          `thrift:"columns,3"`
	Attributes     map[string]Text `thrift:"attributes,4"`
}

func NewScannerOpenWithPrefixArgs() *ScannerOpenWithPrefixArgs {
	rval := &ScannerOpenWithPrefixArgs{}
	return rval
}

func (p *ScannerOpenWithPrefixArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartAndPrefix = temp
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem254 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem254 = temp
		}
		p.Columns = append(p.Columns, _elem254)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key255 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key255 = string(temp)
		}
		var _val256 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val256 = temp
		}
		p.Attributes[_key255] = _val256
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithPrefix_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartAndPrefix != nil {
		if err := oprot.WriteFieldBegin("startAndPrefix", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startAndPrefix: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartAndPrefix); err != nil {
			return fmt.Errorf("%T.startAndPrefix (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startAndPrefix: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithPrefixArgs(%+v)", *p)
}

type ScannerOpenWithPrefixResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenWithPrefixResult() *ScannerOpenWithPrefixResult {
	rval := &ScannerOpenWithPrefixResult{}
	return rval
}

func (p *ScannerOpenWithPrefixResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = temp
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithPrefix_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithPrefixResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithPrefixResult(%+v)", *p)
}

type ScannerOpenTsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	StartRow   Text            `thrift:"startRow,2"`
	Columns    []Text          `thrift:"columns,3"`
	Timestamp  int64           `thrift:"timestamp,4"`
	Attributes map[string]Text `thrift:"attributes,5"`
}

func NewScannerOpenTsArgs() *ScannerOpenTsArgs {
	rval := &ScannerOpenTsArgs{}
	return rval
}

func (p *ScannerOpenTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartRow = temp
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem257 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem257 = temp
		}
		p.Columns = append(p.Columns, _elem257)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key258 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key258 = string(temp)
		}
		var _val259 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val259 = temp
		}
		p.Attributes[_key258] = _val259
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartRow != nil {
		if err := oprot.WriteFieldBegin("startRow", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartRow); err != nil {
			return fmt.Errorf("%T.startRow (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenTsArgs(%+v)", *p)
}

type ScannerOpenTsResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenTsResult() *ScannerOpenTsResult {
	rval := &ScannerOpenTsResult{}
	return rval
}

func (p *ScannerOpenTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenTsResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = temp
	}
	return nil
}

func (p *ScannerOpenTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenTsResult(%+v)", *p)
}

type ScannerOpenWithStopTsArgs struct {
	TableName  Text            `thrift:"tableName,1"`
	StartRow   Text            `thrift:"startRow,2"`
	StopRow    Text            `thrift:"stopRow,3"`
	Columns    []Text          `thrift:"columns,4"`
	Timestamp  int64           `thrift:"timestamp,5"`
	Attributes map[string]Text `thrift:"attributes,6"`
}

func NewScannerOpenWithStopTsArgs() *ScannerOpenWithStopTsArgs {
	rval := &ScannerOpenWithStopTsArgs{}
	return rval
}

func (p *ScannerOpenWithStopTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartRow = temp
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.StopRow = temp
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Text, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem260 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem260 = temp
		}
		p.Columns = append(p.Columns, _elem260)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField6(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key261 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_key261 = string(temp)
		}
		var _val262 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val262 = temp
		}
		p.Attributes[_key261] = _val262
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStopTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartRow != nil {
		if err := oprot.WriteFieldBegin("startRow", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartRow); err != nil {
			return fmt.Errorf("%T.startRow (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.StopRow != nil {
		if err := oprot.WriteFieldBegin("stopRow", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:stopRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StopRow); err != nil {
			return fmt.Errorf("%T.stopRow (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:stopRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:timestamp: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopTsArgs(%+v)", *p)
}

type ScannerOpenWithStopTsResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenWithStopTsResult() *ScannerOpenWithStopTsResult {
	rval := &ScannerOpenWithStopTsResult{}
	return rval
}

func (p *ScannerOpenWithStopTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = temp
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStopTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopTsResult(%+v)", *p)
}

type ScannerGetArgs struct {
	Id ScannerID `thrift:"id,1"`
}

func NewScannerGetArgs() *ScannerGetArgs {
	rval := &ScannerGetArgs{}
	return rval
}

func (p *ScannerGetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := ScannerID(v)
		p.Id = temp
	}
	return nil
}

func (p *ScannerGetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGet_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *ScannerGetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetArgs(%+v)", *p)
}

type ScannerGetResult struct {
	Success []*TRowResult_   `thrift:"success,0"`
	Io      *IOError         `thrift:"io,1"`
	Ia      *IllegalArgument `thrift:"ia,2"`
}

func NewScannerGetResult() *ScannerGetResult {
	rval := &ScannerGetResult{}
	return rval
}

func (p *ScannerGetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem263 := NewTRowResult_()
		if err := _elem263.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem263, err)
		}
		p.Success = append(p.Success, _elem263)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerGetResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerGetResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *ScannerGetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGet_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetResult(%+v)", *p)
}

type ScannerGetListArgs struct {
	Id     ScannerID `thrift:"id,1"`
	NbRows int32     `thrift:"nbRows,2"`
}

func NewScannerGetListArgs() *ScannerGetListArgs {
	rval := &ScannerGetListArgs{}
	return rval
}

func (p *ScannerGetListArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetListArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := ScannerID(v)
		p.Id = temp
	}
	return nil
}

func (p *ScannerGetListArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.NbRows = v
	}
	return nil
}

func (p *ScannerGetListArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGetList_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetListArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *ScannerGetListArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("nbRows", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:nbRows: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NbRows)); err != nil {
		return fmt.Errorf("%T.nbRows (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:nbRows: %s", p, err)
	}
	return err
}

func (p *ScannerGetListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetListArgs(%+v)", *p)
}

type ScannerGetListResult struct {
	Success []*TRowResult_   `thrift:"success,0"`
	Io      *IOError         `thrift:"io,1"`
	Ia      *IllegalArgument `thrift:"ia,2"`
}

func NewScannerGetListResult() *ScannerGetListResult {
	rval := &ScannerGetListResult{}
	return rval
}

func (p *ScannerGetListResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetListResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem264 := NewTRowResult_()
		if err := _elem264.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem264, err)
		}
		p.Success = append(p.Success, _elem264)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerGetListResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerGetListResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *ScannerGetListResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGetList_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetListResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetListResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetListResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetListResult(%+v)", *p)
}

type ScannerCloseArgs struct {
	Id ScannerID `thrift:"id,1"`
}

func NewScannerCloseArgs() *ScannerCloseArgs {
	rval := &ScannerCloseArgs{}
	return rval
}

func (p *ScannerCloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerCloseArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := ScannerID(v)
		p.Id = temp
	}
	return nil
}

func (p *ScannerCloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerClose_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerCloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *ScannerCloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerCloseArgs(%+v)", *p)
}

type ScannerCloseResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewScannerCloseResult() *ScannerCloseResult {
	rval := &ScannerCloseResult{}
	return rval
}

func (p *ScannerCloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerCloseResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerCloseResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *ScannerCloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerClose_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerCloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerCloseResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *ScannerCloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerCloseResult(%+v)", *p)
}

type GetRowOrBeforeArgs struct {
	TableName Text `thrift:"tableName,1"`
	Row       Text `thrift:"row,2"`
	Family    Text `thrift:"family,3"`
}

func NewGetRowOrBeforeArgs() *GetRowOrBeforeArgs {
	rval := &GetRowOrBeforeArgs{}
	return rval
}

func (p *GetRowOrBeforeArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowOrBeforeArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowOrBeforeArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowOrBeforeArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Family = temp
	}
	return nil
}

func (p *GetRowOrBeforeArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowOrBefore_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowOrBeforeArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Family != nil {
		if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Family); err != nil {
			return fmt.Errorf("%T.family (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:family: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowOrBeforeArgs(%+v)", *p)
}

type GetRowOrBeforeResult struct {
	Success []*TCell `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetRowOrBeforeResult() *GetRowOrBeforeResult {
	rval := &GetRowOrBeforeResult{}
	return rval
}

func (p *GetRowOrBeforeResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TCell, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem265 := NewTCell()
		if err := _elem265.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem265, err)
		}
		p.Success = append(p.Success, _elem265)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowOrBefore_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowOrBeforeResult(%+v)", *p)
}

type GetRegionInfoArgs struct {
	Row Text `thrift:"row,1"`
}

func NewGetRegionInfoArgs() *GetRegionInfoArgs {
	rval := &GetRegionInfoArgs{}
	return rval
}

func (p *GetRegionInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRegionInfoArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRegionInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRegionInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRegionInfoArgs(%+v)", *p)
}

type GetRegionInfoResult struct {
	Success *TRegionInfo `thrift:"success,0"`
	Io      *IOError     `thrift:"io,1"`
}

func NewGetRegionInfoResult() *GetRegionInfoResult {
	rval := &GetRegionInfoResult{}
	return rval
}

func (p *GetRegionInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRegionInfoResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewTRegionInfo()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetRegionInfoResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRegionInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRegionInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRegionInfoResult(%+v)", *p)
}
