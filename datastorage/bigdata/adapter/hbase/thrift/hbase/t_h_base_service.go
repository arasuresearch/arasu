// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package hbase

import (
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf

type THBaseService interface {
	// Test for the existence of columns in the table, as specified in the TGet.
	//
	// @return true if the specified TGet matches one or more keys, false if not
	//
	// Parameters:
	//  - Table: the table to check on
	//  - Get: the TGet to check for
	Exists(table []byte, get *TGet) (r bool, err error)
	// Method for getting data from a row.
	//
	// If the row cannot be found an empty Result is returned.
	// This can be checked by the empty field of the TResult
	//
	// @return the result
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Get: the TGet to fetch
	Get(table []byte, get *TGet) (r *TResult_, err error)
	// Method for getting multiple rows.
	//
	// If a row cannot be found there will be a null
	// value in the result list for that TGet at the
	// same position.
	//
	// So the Results are in the same order as the TGets.
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Gets: a list of TGets to fetch, the Result list
	// will have the Results at corresponding positions
	// or null if there was an error
	GetMultiple(table []byte, gets []*TGet) (r []*TResult_, err error)
	// Commit a TPut to a table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Put: the TPut to put
	Put(table []byte, put *TPut) (err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the TPut.
	//
	// @return true if the new put was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and put to
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - Put: the TPut to put if the check succeeds
	CheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, put *TPut) (r bool, err error)
	// Commit a List of Puts to the table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Puts: a list of TPuts to commit
	PutMultiple(table []byte, puts []*TPut) (err error)
	// Deletes as specified by the TDelete.
	//
	// Note: "delete" is a reserved keyword and cannot be used in Thrift
	// thus the inconsistent naming scheme from the other functions.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - DeleteSingle: the TDelete to delete
	DeleteSingle(table []byte, deleteSingle *TDelete) (err error)
	// Bulk commit a List of TDeletes to the table.
	//
	// This returns a list of TDeletes that were not
	// executed. So if everything succeeds you'll
	// receive an empty list.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - Deletes: list of TDeletes to delete
	DeleteMultiple(table []byte, deletes []*TDelete) (r []*TDelete, err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the delete.
	//
	// @return true if the new delete was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and delete from
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - DeleteSingle: the TDelete to execute if the check succeeds
	CheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, deleteSingle *TDelete) (r bool, err error)
	// Parameters:
	//  - Table: the table to increment the value on
	//  - Increment: the TIncrement to increment
	Increment(table []byte, increment *TIncrement) (r *TResult_, err error)
	// Get a Scanner for the provided TScan object.
	//
	// @return Scanner Id to be used with other scanner procedures
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Scan: the scan object to get a Scanner for
	OpenScanner(table []byte, scan *TScan) (r int32, err error)
	// Grabs multiple rows from a Scanner.
	//
	// @return Between zero and numRows TResults
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
	//  - NumRows: number of rows to return
	GetScannerRows(scannerId int32, numRows int32) (r []*TResult_, err error)
	// Closes the scanner. Should be called to free server side resources timely.
	// Typically close once the scanner is not needed anymore, i.e. after looping
	// over it to get all the required rows.
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to close *
	CloseScanner(scannerId int32) (err error)
	// mutateRow performs multiple mutations atomically on a single row.
	//
	// Parameters:
	//  - Table: table to apply the mutations
	//  - RowMutations: mutations to apply
	MutateRow(table []byte, rowMutations *TRowMutations) (err error)
	// Get results for the provided TScan object.
	// This helper function opens a scanner, get the results and close the scanner.
	//
	// @return between zero and numRows TResults
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Scan: the scan object to get a Scanner for
	//  - NumRows: number of rows to return
	GetScannerResults(table []byte, scan *TScan, numRows int32) (r []*TResult_, err error)
}

type THBaseServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewTHBaseServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *THBaseServiceClient {
	return &THBaseServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewTHBaseServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *THBaseServiceClient {
	return &THBaseServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Test for the existence of columns in the table, as specified in the TGet.
//
// @return true if the specified TGet matches one or more keys, false if not
//
// Parameters:
//  - Table: the table to check on
//  - Get: the TGet to check for
func (p *THBaseServiceClient) Exists(table []byte, get *TGet) (r bool, err error) {
	if err = p.sendExists(table, get); err != nil {
		return
	}
	return p.recvExists()
}

func (p *THBaseServiceClient) sendExists(table []byte, get *TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("exists", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args15 := NewExistsArgs()
	args15.Table = table
	args15.Get = get
	if err = args15.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvExists() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error17 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error18 error
		error18, err = error17.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error18
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "exists failed: out of sequence response")
		return
	}
	result16 := NewExistsResult()
	if err = result16.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result16.Io != nil {
		err = result16.Io
		return
	}
	value = result16.Success
	return
}

// Method for getting data from a row.
//
// If the row cannot be found an empty Result is returned.
// This can be checked by the empty field of the TResult
//
// @return the result
//
// Parameters:
//  - Table: the table to get from
//  - Get: the TGet to fetch
func (p *THBaseServiceClient) Get(table []byte, get *TGet) (r *TResult_, err error) {
	if err = p.sendGet(table, get); err != nil {
		return
	}
	return p.recvGet()
}

func (p *THBaseServiceClient) sendGet(table []byte, get *TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args19 := NewGetArgs()
	args19.Table = table
	args19.Get = get
	if err = args19.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGet() (value *TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error21 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error22 error
		error22, err = error21.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error22
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	result20 := NewGetResult()
	if err = result20.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result20.Io != nil {
		err = result20.Io
		return
	}
	value = result20.Success
	return
}

// Method for getting multiple rows.
//
// If a row cannot be found there will be a null
// value in the result list for that TGet at the
// same position.
//
// So the Results are in the same order as the TGets.
//
// Parameters:
//  - Table: the table to get from
//  - Gets: a list of TGets to fetch, the Result list
// will have the Results at corresponding positions
// or null if there was an error
func (p *THBaseServiceClient) GetMultiple(table []byte, gets []*TGet) (r []*TResult_, err error) {
	if err = p.sendGetMultiple(table, gets); err != nil {
		return
	}
	return p.recvGetMultiple()
}

func (p *THBaseServiceClient) sendGetMultiple(table []byte, gets []*TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getMultiple", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args23 := NewGetMultipleArgs()
	args23.Table = table
	args23.Gets = gets
	if err = args23.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetMultiple() (value []*TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error25 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error26 error
		error26, err = error25.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error26
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getMultiple failed: out of sequence response")
		return
	}
	result24 := NewGetMultipleResult()
	if err = result24.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result24.Io != nil {
		err = result24.Io
		return
	}
	value = result24.Success
	return
}

// Commit a TPut to a table.
//
// Parameters:
//  - Table: the table to put data in
//  - Put: the TPut to put
func (p *THBaseServiceClient) Put(table []byte, put *TPut) (err error) {
	if err = p.sendPut(table, put); err != nil {
		return
	}
	return p.recvPut()
}

func (p *THBaseServiceClient) sendPut(table []byte, put *TPut) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("put", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args27 := NewPutArgs()
	args27.Table = table
	args27.Put = put
	if err = args27.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvPut() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error29 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error30 error
		error30, err = error29.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error30
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "put failed: out of sequence response")
		return
	}
	result28 := NewPutResult()
	if err = result28.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result28.Io != nil {
		err = result28.Io
		return
	}
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the TPut.
//
// @return true if the new put was executed, false otherwise
//
// Parameters:
//  - Table: to check in and put to
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Put: the TPut to put if the check succeeds
func (p *THBaseServiceClient) CheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, put *TPut) (r bool, err error) {
	if err = p.sendCheckAndPut(table, row, family, qualifier, value, put); err != nil {
		return
	}
	return p.recvCheckAndPut()
}

func (p *THBaseServiceClient) sendCheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, put *TPut) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkAndPut", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args31 := NewCheckAndPutArgs()
	args31.Table = table
	args31.Row = row
	args31.Family = family
	args31.Qualifier = qualifier
	args31.Value = value
	args31.Put = put
	if err = args31.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCheckAndPut() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error33 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error34 error
		error34, err = error33.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error34
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndPut failed: out of sequence response")
		return
	}
	result32 := NewCheckAndPutResult()
	if err = result32.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result32.Io != nil {
		err = result32.Io
		return
	}
	value = result32.Success
	return
}

// Commit a List of Puts to the table.
//
// Parameters:
//  - Table: the table to put data in
//  - Puts: a list of TPuts to commit
func (p *THBaseServiceClient) PutMultiple(table []byte, puts []*TPut) (err error) {
	if err = p.sendPutMultiple(table, puts); err != nil {
		return
	}
	return p.recvPutMultiple()
}

func (p *THBaseServiceClient) sendPutMultiple(table []byte, puts []*TPut) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("putMultiple", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args35 := NewPutMultipleArgs()
	args35.Table = table
	args35.Puts = puts
	if err = args35.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvPutMultiple() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error37 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error38 error
		error38, err = error37.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error38
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "putMultiple failed: out of sequence response")
		return
	}
	result36 := NewPutMultipleResult()
	if err = result36.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result36.Io != nil {
		err = result36.Io
		return
	}
	return
}

// Deletes as specified by the TDelete.
//
// Note: "delete" is a reserved keyword and cannot be used in Thrift
// thus the inconsistent naming scheme from the other functions.
//
// Parameters:
//  - Table: the table to delete from
//  - DeleteSingle: the TDelete to delete
func (p *THBaseServiceClient) DeleteSingle(table []byte, deleteSingle *TDelete) (err error) {
	if err = p.sendDeleteSingle(table, deleteSingle); err != nil {
		return
	}
	return p.recvDeleteSingle()
}

func (p *THBaseServiceClient) sendDeleteSingle(table []byte, deleteSingle *TDelete) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteSingle", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args39 := NewDeleteSingleArgs()
	args39.Table = table
	args39.DeleteSingle = deleteSingle
	if err = args39.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDeleteSingle() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error41 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error42 error
		error42, err = error41.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error42
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteSingle failed: out of sequence response")
		return
	}
	result40 := NewDeleteSingleResult()
	if err = result40.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result40.Io != nil {
		err = result40.Io
		return
	}
	return
}

// Bulk commit a List of TDeletes to the table.
//
// This returns a list of TDeletes that were not
// executed. So if everything succeeds you'll
// receive an empty list.
//
// Parameters:
//  - Table: the table to delete from
//  - Deletes: list of TDeletes to delete
func (p *THBaseServiceClient) DeleteMultiple(table []byte, deletes []*TDelete) (r []*TDelete, err error) {
	if err = p.sendDeleteMultiple(table, deletes); err != nil {
		return
	}
	return p.recvDeleteMultiple()
}

func (p *THBaseServiceClient) sendDeleteMultiple(table []byte, deletes []*TDelete) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteMultiple", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args43 := NewDeleteMultipleArgs()
	args43.Table = table
	args43.Deletes = deletes
	if err = args43.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDeleteMultiple() (value []*TDelete, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error45 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error46 error
		error46, err = error45.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error46
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteMultiple failed: out of sequence response")
		return
	}
	result44 := NewDeleteMultipleResult()
	if err = result44.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result44.Io != nil {
		err = result44.Io
		return
	}
	value = result44.Success
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the delete.
//
// @return true if the new delete was executed, false otherwise
//
// Parameters:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - DeleteSingle: the TDelete to execute if the check succeeds
func (p *THBaseServiceClient) CheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, deleteSingle *TDelete) (r bool, err error) {
	if err = p.sendCheckAndDelete(table, row, family, qualifier, value, deleteSingle); err != nil {
		return
	}
	return p.recvCheckAndDelete()
}

func (p *THBaseServiceClient) sendCheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, deleteSingle *TDelete) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkAndDelete", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args47 := NewCheckAndDeleteArgs()
	args47.Table = table
	args47.Row = row
	args47.Family = family
	args47.Qualifier = qualifier
	args47.Value = value
	args47.DeleteSingle = deleteSingle
	if err = args47.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCheckAndDelete() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error49 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error50 error
		error50, err = error49.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error50
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndDelete failed: out of sequence response")
		return
	}
	result48 := NewCheckAndDeleteResult()
	if err = result48.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result48.Io != nil {
		err = result48.Io
		return
	}
	value = result48.Success
	return
}

// Parameters:
//  - Table: the table to increment the value on
//  - Increment: the TIncrement to increment
func (p *THBaseServiceClient) Increment(table []byte, increment *TIncrement) (r *TResult_, err error) {
	if err = p.sendIncrement(table, increment); err != nil {
		return
	}
	return p.recvIncrement()
}

func (p *THBaseServiceClient) sendIncrement(table []byte, increment *TIncrement) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("increment", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args51 := NewIncrementArgs()
	args51.Table = table
	args51.Increment = increment
	if err = args51.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvIncrement() (value *TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error53 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error54 error
		error54, err = error53.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error54
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "increment failed: out of sequence response")
		return
	}
	result52 := NewIncrementResult()
	if err = result52.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result52.Io != nil {
		err = result52.Io
		return
	}
	value = result52.Success
	return
}

// Get a Scanner for the provided TScan object.
//
// @return Scanner Id to be used with other scanner procedures
//
// Parameters:
//  - Table: the table to get the Scanner for
//  - Scan: the scan object to get a Scanner for
func (p *THBaseServiceClient) OpenScanner(table []byte, scan *TScan) (r int32, err error) {
	if err = p.sendOpenScanner(table, scan); err != nil {
		return
	}
	return p.recvOpenScanner()
}

func (p *THBaseServiceClient) sendOpenScanner(table []byte, scan *TScan) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("openScanner", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args55 := NewOpenScannerArgs()
	args55.Table = table
	args55.Scan = scan
	if err = args55.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvOpenScanner() (value int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error57 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error58 error
		error58, err = error57.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error58
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "openScanner failed: out of sequence response")
		return
	}
	result56 := NewOpenScannerResult()
	if err = result56.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result56.Io != nil {
		err = result56.Io
		return
	}
	value = result56.Success
	return
}

// Grabs multiple rows from a Scanner.
//
// @return Between zero and numRows TResults
//
// Parameters:
//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
//  - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerRows(scannerId int32, numRows int32) (r []*TResult_, err error) {
	if err = p.sendGetScannerRows(scannerId, numRows); err != nil {
		return
	}
	return p.recvGetScannerRows()
}

func (p *THBaseServiceClient) sendGetScannerRows(scannerId int32, numRows int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getScannerRows", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args59 := NewGetScannerRowsArgs()
	args59.ScannerId = scannerId
	args59.NumRows = numRows
	if err = args59.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetScannerRows() (value []*TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error61 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error62 error
		error62, err = error61.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error62
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getScannerRows failed: out of sequence response")
		return
	}
	result60 := NewGetScannerRowsResult()
	if err = result60.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result60.Io != nil {
		err = result60.Io
		return
	} else if result60.Ia != nil {
		err = result60.Ia
		return
	}
	value = result60.Success
	return
}

// Closes the scanner. Should be called to free server side resources timely.
// Typically close once the scanner is not needed anymore, i.e. after looping
// over it to get all the required rows.
//
// Parameters:
//  - ScannerId: the Id of the Scanner to close *
func (p *THBaseServiceClient) CloseScanner(scannerId int32) (err error) {
	if err = p.sendCloseScanner(scannerId); err != nil {
		return
	}
	return p.recvCloseScanner()
}

func (p *THBaseServiceClient) sendCloseScanner(scannerId int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("closeScanner", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args63 := NewCloseScannerArgs()
	args63.ScannerId = scannerId
	if err = args63.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCloseScanner() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error65 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error66 error
		error66, err = error65.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error66
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "closeScanner failed: out of sequence response")
		return
	}
	result64 := NewCloseScannerResult()
	if err = result64.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result64.Io != nil {
		err = result64.Io
		return
	} else if result64.Ia != nil {
		err = result64.Ia
		return
	}
	return
}

// mutateRow performs multiple mutations atomically on a single row.
//
// Parameters:
//  - Table: table to apply the mutations
//  - RowMutations: mutations to apply
func (p *THBaseServiceClient) MutateRow(table []byte, rowMutations *TRowMutations) (err error) {
	if err = p.sendMutateRow(table, rowMutations); err != nil {
		return
	}
	return p.recvMutateRow()
}

func (p *THBaseServiceClient) sendMutateRow(table []byte, rowMutations *TRowMutations) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRow", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args67 := NewMutateRowArgs()
	args67.Table = table
	args67.RowMutations = rowMutations
	if err = args67.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvMutateRow() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error69 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error70 error
		error70, err = error69.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error70
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRow failed: out of sequence response")
		return
	}
	result68 := NewMutateRowResult()
	if err = result68.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result68.Io != nil {
		err = result68.Io
		return
	}
	return
}

// Get results for the provided TScan object.
// This helper function opens a scanner, get the results and close the scanner.
//
// @return between zero and numRows TResults
//
// Parameters:
//  - Table: the table to get the Scanner for
//  - Scan: the scan object to get a Scanner for
//  - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerResults(table []byte, scan *TScan, numRows int32) (r []*TResult_, err error) {
	if err = p.sendGetScannerResults(table, scan, numRows); err != nil {
		return
	}
	return p.recvGetScannerResults()
}

func (p *THBaseServiceClient) sendGetScannerResults(table []byte, scan *TScan, numRows int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getScannerResults", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args71 := NewGetScannerResultsArgs()
	args71.Table = table
	args71.Scan = scan
	args71.NumRows = numRows
	if err = args71.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetScannerResults() (value []*TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error73 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error74 error
		error74, err = error73.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error74
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getScannerResults failed: out of sequence response")
		return
	}
	result72 := NewGetScannerResultsResult()
	if err = result72.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result72.Io != nil {
		err = result72.Io
		return
	}
	value = result72.Success
	return
}

type THBaseServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      THBaseService
}

func (p *THBaseServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *THBaseServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *THBaseServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewTHBaseServiceProcessor(handler THBaseService) *THBaseServiceProcessor {

	self75 := &THBaseServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self75.processorMap["exists"] = &tHBaseServiceProcessorExists{handler: handler}
	self75.processorMap["get"] = &tHBaseServiceProcessorGet{handler: handler}
	self75.processorMap["getMultiple"] = &tHBaseServiceProcessorGetMultiple{handler: handler}
	self75.processorMap["put"] = &tHBaseServiceProcessorPut{handler: handler}
	self75.processorMap["checkAndPut"] = &tHBaseServiceProcessorCheckAndPut{handler: handler}
	self75.processorMap["putMultiple"] = &tHBaseServiceProcessorPutMultiple{handler: handler}
	self75.processorMap["deleteSingle"] = &tHBaseServiceProcessorDeleteSingle{handler: handler}
	self75.processorMap["deleteMultiple"] = &tHBaseServiceProcessorDeleteMultiple{handler: handler}
	self75.processorMap["checkAndDelete"] = &tHBaseServiceProcessorCheckAndDelete{handler: handler}
	self75.processorMap["increment"] = &tHBaseServiceProcessorIncrement{handler: handler}
	self75.processorMap["openScanner"] = &tHBaseServiceProcessorOpenScanner{handler: handler}
	self75.processorMap["getScannerRows"] = &tHBaseServiceProcessorGetScannerRows{handler: handler}
	self75.processorMap["closeScanner"] = &tHBaseServiceProcessorCloseScanner{handler: handler}
	self75.processorMap["mutateRow"] = &tHBaseServiceProcessorMutateRow{handler: handler}
	self75.processorMap["getScannerResults"] = &tHBaseServiceProcessorGetScannerResults{handler: handler}
	return self75
}

func (p *THBaseServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x76 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x76.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x76

}

type tHBaseServiceProcessorExists struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorExists) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewExistsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("exists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewExistsResult()
	var err2 error
	if result.Success, err2 = p.handler.Exists(args.Table, args.Get); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exists: "+err2.Error())
			oprot.WriteMessageBegin("exists", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("exists", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGet struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetResult()
	var err2 error
	if result.Success, err2 = p.handler.Get(args.Table, args.Get); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetMultipleArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetMultipleResult()
	var err2 error
	if result.Success, err2 = p.handler.GetMultiple(args.Table, args.Gets); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getMultiple: "+err2.Error())
			oprot.WriteMessageBegin("getMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPut) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewPutArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewPutResult()
	var err2 error
	if err2 = p.handler.Put(args.Table, args.Put); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing put: "+err2.Error())
			oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("put", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndPut) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCheckAndPutArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewCheckAndPutResult()
	var err2 error
	if result.Success, err2 = p.handler.CheckAndPut(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Put); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndPut: "+err2.Error())
			oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("checkAndPut", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorPutMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPutMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewPutMultipleArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("putMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewPutMultipleResult()
	var err2 error
	if err2 = p.handler.PutMultiple(args.Table, args.Puts); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing putMultiple: "+err2.Error())
			oprot.WriteMessageBegin("putMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("putMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteSingle struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteSingle) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteSingleArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteSingle", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewDeleteSingleResult()
	var err2 error
	if err2 = p.handler.DeleteSingle(args.Table, args.DeleteSingle); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteSingle: "+err2.Error())
			oprot.WriteMessageBegin("deleteSingle", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteSingle", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteMultipleArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewDeleteMultipleResult()
	var err2 error
	if result.Success, err2 = p.handler.DeleteMultiple(args.Table, args.Deletes); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteMultiple: "+err2.Error())
			oprot.WriteMessageBegin("deleteMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndDelete struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndDelete) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCheckAndDeleteArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndDelete", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewCheckAndDeleteResult()
	var err2 error
	if result.Success, err2 = p.handler.CheckAndDelete(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.DeleteSingle); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndDelete: "+err2.Error())
			oprot.WriteMessageBegin("checkAndDelete", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("checkAndDelete", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIncrement struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIncrement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewIncrementArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewIncrementResult()
	var err2 error
	if result.Success, err2 = p.handler.Increment(args.Table, args.Increment); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: "+err2.Error())
			oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("increment", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorOpenScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorOpenScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOpenScannerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("openScanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewOpenScannerResult()
	var err2 error
	if result.Success, err2 = p.handler.OpenScanner(args.Table, args.Scan); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing openScanner: "+err2.Error())
			oprot.WriteMessageBegin("openScanner", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("openScanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerRows struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetScannerRowsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getScannerRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetScannerRowsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetScannerRows(args.ScannerId, args.NumRows); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerRows: "+err2.Error())
			oprot.WriteMessageBegin("getScannerRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getScannerRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCloseScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCloseScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCloseScannerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("closeScanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewCloseScannerResult()
	var err2 error
	if err2 = p.handler.CloseScanner(args.ScannerId); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing closeScanner: "+err2.Error())
			oprot.WriteMessageBegin("closeScanner", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("closeScanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorMutateRow struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorMutateRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutateRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewMutateRowResult()
	var err2 error
	if err2 = p.handler.MutateRow(args.Table, args.RowMutations); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRow: "+err2.Error())
			oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerResults struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerResults) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetScannerResultsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getScannerResults", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NewGetScannerResultsResult()
	var err2 error
	if result.Success, err2 = p.handler.GetScannerResults(args.Table, args.Scan, args.NumRows); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerResults: "+err2.Error())
			oprot.WriteMessageBegin("getScannerResults", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getScannerResults", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type ExistsArgs struct {
	Table []byte `thrift:"table,1,required"`
	Get   *TGet  `thrift:"get,2,required"`
}

func NewExistsArgs() *ExistsArgs {
	rval := &ExistsArgs{}
	return rval
}

func (p *ExistsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *ExistsArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Get = NewTGet()
	if err := p.Get.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Get, err)
	}
	return nil
}

func (p *ExistsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *ExistsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Get != nil {
		if err := oprot.WriteFieldBegin("get", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:get: %s", p, err)
		}
		if err := p.Get.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Get, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:get: %s", p, err)
		}
	}
	return err
}

func (p *ExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsArgs(%+v)", *p)
}

type ExistsResult struct {
	Success bool      `thrift:"success,0"`
	Io      *TIOError `thrift:"io,1"`
}

func NewExistsResult() *ExistsResult {
	rval := &ExistsResult{}
	return rval
}

func (p *ExistsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExistsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ExistsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExistsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsResult(%+v)", *p)
}

type GetArgs struct {
	Table []byte `thrift:"table,1,required"`
	Get   *TGet  `thrift:"get,2,required"`
}

func NewGetArgs() *GetArgs {
	rval := &GetArgs{}
	return rval
}

func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Get = NewTGet()
	if err := p.Get.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Get, err)
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Get != nil {
		if err := oprot.WriteFieldBegin("get", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:get: %s", p, err)
		}
		if err := p.Get.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Get, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:get: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success *TResult_ `thrift:"success,0"`
	Io      *TIOError `thrift:"io,1"`
}

func NewGetResult() *GetResult {
	rval := &GetResult{}
	return rval
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewTResult_()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type GetMultipleArgs struct {
	Table []byte  `thrift:"table,1,required"`
	Gets  []*TGet `thrift:"gets,2,required"`
}

func NewGetMultipleArgs() *GetMultipleArgs {
	rval := &GetMultipleArgs{}
	return rval
}

func (p *GetMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMultipleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetMultipleArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TGet, 0, size)
	p.Gets = tSlice
	for i := 0; i < size; i++ {
		_elem77 := NewTGet()
		if err := _elem77.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem77, err)
		}
		p.Gets = append(p.Gets, _elem77)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMultiple_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *GetMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Gets != nil {
		if err := oprot.WriteFieldBegin("gets", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:gets: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Gets)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Gets {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:gets: %s", p, err)
		}
	}
	return err
}

func (p *GetMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMultipleArgs(%+v)", *p)
}

type GetMultipleResult struct {
	Success []*TResult_ `thrift:"success,0"`
	Io      *TIOError   `thrift:"io,1"`
}

func NewGetMultipleResult() *GetMultipleResult {
	rval := &GetMultipleResult{}
	return rval
}

func (p *GetMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMultipleResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem78 := NewTResult_()
		if err := _elem78.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem78, err)
		}
		p.Success = append(p.Success, _elem78)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetMultipleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMultiple_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMultipleResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMultipleResult(%+v)", *p)
}

type PutArgs struct {
	Table []byte `thrift:"table,1,required"`
	Put   *TPut  `thrift:"put,2,required"`
}

func NewPutArgs() *PutArgs {
	rval := &PutArgs{}
	return rval
}

func (p *PutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *PutArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Put = NewTPut()
	if err := p.Put.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Put, err)
	}
	return nil
}

func (p *PutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *PutArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Put != nil {
		if err := oprot.WriteFieldBegin("put", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:put: %s", p, err)
		}
		if err := p.Put.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Put, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:put: %s", p, err)
		}
	}
	return err
}

func (p *PutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutArgs(%+v)", *p)
}

type PutResult struct {
	Io *TIOError `thrift:"io,1"`
}

func NewPutResult() *PutResult {
	rval := &PutResult{}
	return rval
}

func (p *PutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *PutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *PutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutResult(%+v)", *p)
}

type CheckAndPutArgs struct {
	Table     []byte `thrift:"table,1,required"`
	Row       []byte `thrift:"row,2,required"`
	Family    []byte `thrift:"family,3,required"`
	Qualifier []byte `thrift:"qualifier,4,required"`
	Value     []byte `thrift:"value,5"`
	Put       *TPut  `thrift:"put,6,required"`
}

func NewCheckAndPutArgs() *CheckAndPutArgs {
	rval := &CheckAndPutArgs{}
	return rval
}

func (p *CheckAndPutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField6(iprot thrift.TProtocol) error {
	p.Put = NewTPut()
	if err := p.Put.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Put, err)
	}
	return nil
}

func (p *CheckAndPutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndPutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Family != nil {
		if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Family); err != nil {
			return fmt.Errorf("%T.family (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:family: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Qualifier != nil {
		if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:qualifier: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Qualifier); err != nil {
			return fmt.Errorf("%T.qualifier (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:qualifier: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Value != nil {
		if err := oprot.WriteFieldBegin("value", thrift.STRING, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:value: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Value); err != nil {
			return fmt.Errorf("%T.value (5) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:value: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if p.Put != nil {
		if err := oprot.WriteFieldBegin("put", thrift.STRUCT, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:put: %s", p, err)
		}
		if err := p.Put.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Put, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:put: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndPutArgs(%+v)", *p)
}

type CheckAndPutResult struct {
	Success bool      `thrift:"success,0"`
	Io      *TIOError `thrift:"io,1"`
}

func NewCheckAndPutResult() *CheckAndPutResult {
	rval := &CheckAndPutResult{}
	return rval
}

func (p *CheckAndPutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndPutResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *CheckAndPutResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CheckAndPutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndPutResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *CheckAndPutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndPutResult(%+v)", *p)
}

type PutMultipleArgs struct {
	Table []byte  `thrift:"table,1,required"`
	Puts  []*TPut `thrift:"puts,2,required"`
}

func NewPutMultipleArgs() *PutMultipleArgs {
	rval := &PutMultipleArgs{}
	return rval
}

func (p *PutMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutMultipleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *PutMultipleArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TPut, 0, size)
	p.Puts = tSlice
	for i := 0; i < size; i++ {
		_elem79 := NewTPut()
		if err := _elem79.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem79, err)
		}
		p.Puts = append(p.Puts, _elem79)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *PutMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("putMultiple_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *PutMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Puts != nil {
		if err := oprot.WriteFieldBegin("puts", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:puts: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Puts)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Puts {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:puts: %s", p, err)
		}
	}
	return err
}

func (p *PutMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutMultipleArgs(%+v)", *p)
}

type PutMultipleResult struct {
	Io *TIOError `thrift:"io,1"`
}

func NewPutMultipleResult() *PutMultipleResult {
	rval := &PutMultipleResult{}
	return rval
}

func (p *PutMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutMultipleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *PutMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("putMultiple_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *PutMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutMultipleResult(%+v)", *p)
}

type DeleteSingleArgs struct {
	Table        []byte   `thrift:"table,1,required"`
	DeleteSingle *TDelete `thrift:"deleteSingle,2,required"`
}

func NewDeleteSingleArgs() *DeleteSingleArgs {
	rval := &DeleteSingleArgs{}
	return rval
}

func (p *DeleteSingleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteSingleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *DeleteSingleArgs) ReadField2(iprot thrift.TProtocol) error {
	p.DeleteSingle = NewTDelete()
	if err := p.DeleteSingle.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.DeleteSingle, err)
	}
	return nil
}

func (p *DeleteSingleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteSingle_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteSingleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *DeleteSingleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.DeleteSingle != nil {
		if err := oprot.WriteFieldBegin("deleteSingle", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:deleteSingle: %s", p, err)
		}
		if err := p.DeleteSingle.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.DeleteSingle, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:deleteSingle: %s", p, err)
		}
	}
	return err
}

func (p *DeleteSingleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteSingleArgs(%+v)", *p)
}

type DeleteSingleResult struct {
	Io *TIOError `thrift:"io,1"`
}

func NewDeleteSingleResult() *DeleteSingleResult {
	rval := &DeleteSingleResult{}
	return rval
}

func (p *DeleteSingleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteSingleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteSingleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteSingle_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteSingleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteSingleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteSingleResult(%+v)", *p)
}

type DeleteMultipleArgs struct {
	Table   []byte     `thrift:"table,1,required"`
	Deletes []*TDelete `thrift:"deletes,2,required"`
}

func NewDeleteMultipleArgs() *DeleteMultipleArgs {
	rval := &DeleteMultipleArgs{}
	return rval
}

func (p *DeleteMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteMultipleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *DeleteMultipleArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Deletes = tSlice
	for i := 0; i < size; i++ {
		_elem80 := NewTDelete()
		if err := _elem80.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem80, err)
		}
		p.Deletes = append(p.Deletes, _elem80)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DeleteMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteMultiple_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *DeleteMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Deletes != nil {
		if err := oprot.WriteFieldBegin("deletes", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:deletes: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Deletes)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Deletes {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:deletes: %s", p, err)
		}
	}
	return err
}

func (p *DeleteMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteMultipleArgs(%+v)", *p)
}

type DeleteMultipleResult struct {
	Success []*TDelete `thrift:"success,0"`
	Io      *TIOError  `thrift:"io,1"`
}

func NewDeleteMultipleResult() *DeleteMultipleResult {
	rval := &DeleteMultipleResult{}
	return rval
}

func (p *DeleteMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteMultipleResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem81 := NewTDelete()
		if err := _elem81.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem81, err)
		}
		p.Success = append(p.Success, _elem81)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DeleteMultipleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteMultiple_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteMultipleResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DeleteMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteMultipleResult(%+v)", *p)
}

type CheckAndDeleteArgs struct {
	Table        []byte   `thrift:"table,1,required"`
	Row          []byte   `thrift:"row,2,required"`
	Family       []byte   `thrift:"family,3,required"`
	Qualifier    []byte   `thrift:"qualifier,4,required"`
	Value        []byte   `thrift:"value,5"`
	DeleteSingle *TDelete `thrift:"deleteSingle,6,required"`
}

func NewCheckAndDeleteArgs() *CheckAndDeleteArgs {
	rval := &CheckAndDeleteArgs{}
	return rval
}

func (p *CheckAndDeleteArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField6(iprot thrift.TProtocol) error {
	p.DeleteSingle = NewTDelete()
	if err := p.DeleteSingle.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.DeleteSingle, err)
	}
	return nil
}

func (p *CheckAndDeleteArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndDelete_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndDeleteArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Family != nil {
		if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Family); err != nil {
			return fmt.Errorf("%T.family (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:family: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Qualifier != nil {
		if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:qualifier: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Qualifier); err != nil {
			return fmt.Errorf("%T.qualifier (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:qualifier: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Value != nil {
		if err := oprot.WriteFieldBegin("value", thrift.STRING, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:value: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Value); err != nil {
			return fmt.Errorf("%T.value (5) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:value: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if p.DeleteSingle != nil {
		if err := oprot.WriteFieldBegin("deleteSingle", thrift.STRUCT, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:deleteSingle: %s", p, err)
		}
		if err := p.DeleteSingle.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.DeleteSingle, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:deleteSingle: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndDeleteArgs(%+v)", *p)
}

type CheckAndDeleteResult struct {
	Success bool      `thrift:"success,0"`
	Io      *TIOError `thrift:"io,1"`
}

func NewCheckAndDeleteResult() *CheckAndDeleteResult {
	rval := &CheckAndDeleteResult{}
	return rval
}

func (p *CheckAndDeleteResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndDeleteResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *CheckAndDeleteResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CheckAndDeleteResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndDelete_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndDeleteResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndDeleteResult(%+v)", *p)
}

type IncrementArgs struct {
	Table     []byte      `thrift:"table,1,required"`
	Increment *TIncrement `thrift:"increment,2,required"`
}

func NewIncrementArgs() *IncrementArgs {
	rval := &IncrementArgs{}
	return rval
}

func (p *IncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *IncrementArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Increment = NewTIncrement()
	if err := p.Increment.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Increment, err)
	}
	return nil
}

func (p *IncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *IncrementArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Increment != nil {
		if err := oprot.WriteFieldBegin("increment", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:increment: %s", p, err)
		}
		if err := p.Increment.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Increment, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:increment: %s", p, err)
		}
	}
	return err
}

func (p *IncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementArgs(%+v)", *p)
}

type IncrementResult struct {
	Success *TResult_ `thrift:"success,0"`
	Io      *TIOError `thrift:"io,1"`
}

func NewIncrementResult() *IncrementResult {
	rval := &IncrementResult{}
	return rval
}

func (p *IncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewTResult_()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *IncrementResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementResult(%+v)", *p)
}

type OpenScannerArgs struct {
	Table []byte `thrift:"table,1,required"`
	Scan  *TScan `thrift:"scan,2,required"`
}

func NewOpenScannerArgs() *OpenScannerArgs {
	rval := &OpenScannerArgs{}
	return rval
}

func (p *OpenScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *OpenScannerArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Scan = NewTScan()
	if err := p.Scan.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Scan, err)
	}
	return nil
}

func (p *OpenScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openScanner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Scan != nil {
		if err := oprot.WriteFieldBegin("scan", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:scan: %s", p, err)
		}
		if err := p.Scan.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Scan, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:scan: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerArgs(%+v)", *p)
}

type OpenScannerResult struct {
	Success int32     `thrift:"success,0"`
	Io      *TIOError `thrift:"io,1"`
}

func NewOpenScannerResult() *OpenScannerResult {
	rval := &OpenScannerResult{}
	return rval
}

func (p *OpenScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *OpenScannerResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *OpenScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openScanner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *OpenScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerResult(%+v)", *p)
}

type GetScannerRowsArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required"`
	NumRows   int32 `thrift:"numRows,2"`
}

func NewGetScannerRowsArgs() *GetScannerRowsArgs {
	rval := &GetScannerRowsArgs{
		NumRows: 1,
	}
	return rval
}

func (p *GetScannerRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerRowsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *GetScannerRowsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *GetScannerRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scannerId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scannerId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ScannerId)); err != nil {
		return fmt.Errorf("%T.scannerId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scannerId: %s", p, err)
	}
	return err
}

func (p *GetScannerRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numRows", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:numRows: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumRows)); err != nil {
		return fmt.Errorf("%T.numRows (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:numRows: %s", p, err)
	}
	return err
}

func (p *GetScannerRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerRowsArgs(%+v)", *p)
}

type GetScannerRowsResult struct {
	Success []*TResult_       `thrift:"success,0"`
	Io      *TIOError         `thrift:"io,1"`
	Ia      *TIllegalArgument `thrift:"ia,2"`
}

func NewGetScannerRowsResult() *GetScannerRowsResult {
	rval := &GetScannerRowsResult{}
	return rval
}

func (p *GetScannerRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerRowsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem82 := NewTResult_()
		if err := _elem82.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem82, err)
		}
		p.Success = append(p.Success, _elem82)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetScannerRowsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetScannerRowsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewTIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *GetScannerRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerRowsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerRowsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerRowsResult(%+v)", *p)
}

type CloseScannerArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required"`
}

func NewCloseScannerArgs() *CloseScannerArgs {
	rval := &CloseScannerArgs{}
	return rval
}

func (p *CloseScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *CloseScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeScanner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scannerId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scannerId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ScannerId)); err != nil {
		return fmt.Errorf("%T.scannerId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scannerId: %s", p, err)
	}
	return err
}

func (p *CloseScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerArgs(%+v)", *p)
}

type CloseScannerResult struct {
	Io *TIOError         `thrift:"io,1"`
	Ia *TIllegalArgument `thrift:"ia,2"`
}

func NewCloseScannerResult() *CloseScannerResult {
	rval := &CloseScannerResult{}
	return rval
}

func (p *CloseScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CloseScannerResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = NewTIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *CloseScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeScanner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CloseScannerResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *CloseScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerResult(%+v)", *p)
}

type MutateRowArgs struct {
	Table        []byte         `thrift:"table,1,required"`
	RowMutations *TRowMutations `thrift:"rowMutations,2,required"`
}

func NewMutateRowArgs() *MutateRowArgs {
	rval := &MutateRowArgs{}
	return rval
}

func (p *MutateRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *MutateRowArgs) ReadField2(iprot thrift.TProtocol) error {
	p.RowMutations = NewTRowMutations()
	if err := p.RowMutations.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.RowMutations, err)
	}
	return nil
}

func (p *MutateRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.RowMutations != nil {
		if err := oprot.WriteFieldBegin("rowMutations", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rowMutations: %s", p, err)
		}
		if err := p.RowMutations.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.RowMutations, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rowMutations: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowArgs(%+v)", *p)
}

type MutateRowResult struct {
	Io *TIOError `thrift:"io,1"`
}

func NewMutateRowResult() *MutateRowResult {
	rval := &MutateRowResult{}
	return rval
}

func (p *MutateRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowResult(%+v)", *p)
}

type GetScannerResultsArgs struct {
	Table   []byte `thrift:"table,1,required"`
	Scan    *TScan `thrift:"scan,2,required"`
	NumRows int32  `thrift:"numRows,3"`
}

func NewGetScannerResultsArgs() *GetScannerResultsArgs {
	rval := &GetScannerResultsArgs{
		NumRows: 1,
	}
	return rval
}

func (p *GetScannerResultsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerResultsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetScannerResultsArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Scan = NewTScan()
	if err := p.Scan.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Scan, err)
	}
	return nil
}

func (p *GetScannerResultsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *GetScannerResultsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerResults_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerResultsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Table != nil {
		if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Table); err != nil {
			return fmt.Errorf("%T.table (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:table: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerResultsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Scan != nil {
		if err := oprot.WriteFieldBegin("scan", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:scan: %s", p, err)
		}
		if err := p.Scan.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Scan, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:scan: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerResultsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numRows", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:numRows: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumRows)); err != nil {
		return fmt.Errorf("%T.numRows (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:numRows: %s", p, err)
	}
	return err
}

func (p *GetScannerResultsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerResultsArgs(%+v)", *p)
}

type GetScannerResultsResult struct {
	Success []*TResult_ `thrift:"success,0"`
	Io      *TIOError   `thrift:"io,1"`
}

func NewGetScannerResultsResult() *GetScannerResultsResult {
	rval := &GetScannerResultsResult{}
	return rval
}

func (p *GetScannerResultsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerResultsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem83 := NewTResult_()
		if err := _elem83.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem83, err)
		}
		p.Success = append(p.Success, _elem83)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetScannerResultsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = NewTIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetScannerResultsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerResults_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerResultsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerResultsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerResultsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerResultsResult(%+v)", *p)
}
